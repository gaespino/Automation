{
      "s2t_reg": {
            "pm_cr_perfmon_evntsel_aux": {
                  "description": "Perfmon Controls",
                  "cr_offset": 2030,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "slm_cr_offcore_resp0": {
                  "description": "Uncore PerfMon Register 0",
                  "cr_offset": 8742,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "slm_cr_offcore_resp1": {
                  "description": "Uncore PerfMon Register 1",
                  "cr_offset": 8743,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_mci_addr": {
                  "description": "MCA Address Register. Only a write of all 0s is allowed by WRMSR ucode. Skylake i1350467: Allow WRMSR to update all bits if PPPE_ACTIVE. GLM i1958673 (Microserver MCA Enhancements):Allow WRMSR to update all bits if DEBUG_ERR_INJ_CTL.MCBW_E. The creg is restored during C6 restore.",
                  "cr_offset": 1546,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_mci_ctl": {
                  "description": "MCA Control Register. MRM b1598713:Dont #GP on writing ones to the upper part of MCi_CTL because the software model always write one to the whole 64bit",
                  "cr_offset": 1544,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_mci_ctl2": {
                  "description": "MCA Addres Control Register for CMCI. The creg is restored during C6 restore.",
                  "cr_offset": 1552,
                  "numbits": 64,
                  "desired_value": "0x40007fff",
                  "ref_value": "0x500000000"
            },
            "ic_cr_mci_misc": {
                  "description": "MCA MISC Register for CMCI. The creg is restored during C6 restore.",
                  "cr_offset": 1547,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_mci_status": {
                  "description": "MCA Status Register. Only a write of all 0s is allowed by WRMSR ucode. Skylake i1350467: Allow WRMSR to update all bits if PPPE_ACTIVE. GLM i1958673 (Microserver MCA Enhancements):Allow WRMSR to update all bits if DEBUG_ERR_INJ_CTL.MCBW_E.",
                  "cr_offset": 1545,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ia32_cr_rtit_output_base": {
                  "description": "Holds the physical base address where RTIT packets will be written",
                  "cr_offset": 257,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ia32_cr_rtit_output_mask_ptrs": {
                  "description": "Holds the MASK to use when calculating the final address",
                  "cr_offset": 258,
                  "numbits": 64,
                  "desired_value": "0x7f",
                  "ref_value": "0x7f"
            },
            "mec_cr_mci_addr": {
                  "description": "MCA Address Register. WRMSR uCode generates #GP on non-zero writes. Skylake i1350467: Allow WRMSR to update all bits if PPPE_ACTIVE. GLM i1958673 (Microserver MCA Enhancements):Allow WRMSR to update all bits if DEBUG_ERR_INJ_CTL.MCBW_E",
                  "cr_offset": 270,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_mci_ctl": {
                  "description": "MCA Control Register. MRM b1598713:Dont #GP on writing ones to the upper part of MCi_CTL because the software model always write one to the whole 64bit",
                  "cr_offset": 268,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x3"
            },
            "agu_cr_mci_ctl2": {
                  "description": "MCA Control Register 2",
                  "cr_offset": 267,
                  "numbits": 64,
                  "desired_value": "0x40007fff",
                  "ref_value": "0x500000000"
            },
            "mec_cr_mci_status": {
                  "description": "MCA Status Register. WRMSR uCode generates #GP on non-zero writes. Skylake i1350467: Allow WRMSR to update all bits if PPPE_ACTIVE. GLM i1958673 (Microserver MCA Enhancements):Allow WRMSR to update all bits if DEBUG_ERR_INJ_CTL.MCBW_E.",
                  "cr_offset": 269,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ia32_cr_smrr2_physbase": {
                  "description": "SMM Range Register - Physical Base. Used to protect the System Management Mode code set up by the BIOS from attack by CPL 0 code (like OS). See Silvermont xT HAS SMRR doc. This MSR has restrictions on when it can be accessed. This MSR is discussed in the SDM",
                  "cr_offset": 1398,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ia32_cr_smrr2_physmask": {
                  "description": "SMM Range Register - Physical Mask. Used to protect the System Management Mode code set up by the BIOS from attack by CPL 0 code (like OS). See Silvermont xT HAS SMRR2 doc. This MSR has restrictions on when it can be accessed. This MSR is discussed in the SDM",
                  "cr_offset": 1399,
                  "numbits": 64,
                  "desired_value": "0xfffff00000000",
                  "ref_value": "0xfffff00000000"
            },
            "ia32_cr_smrr_physbase": {
                  "description": "SMM Range Register - Physical Base. Used to protect the System Management Mode code set up by the BIOS from attack by CPL 0 code (like OS). See Silvermont xT HAS SMRR doc. This MSR has restrictions on when it can be accessed. This MSR is discussed in the SDM",
                  "cr_offset": 1394,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x78000006"
            },
            "ia32_cr_smrr_physmask": {
                  "description": "SMM Range Register - Physical Mask. Used to protect the System Management Mode code set up by the BIOS from attack by CPL 0 code (like OS). See Silvermont xT HAS SMRR doc. This MSR has restrictions on when it can be accessed. This MSR is discussed in the SDM",
                  "cr_offset": 1395,
                  "numbits": 64,
                  "desired_value": "0xfffff00000000",
                  "ref_value": "0xffffff8000c00"
            },
            "pmh_cr_amrr_base_0": {
                  "description": "Address Match Range Register - Physical Base. Used for Probeless Debug Mode and internal debug. See Silvermont xT HAS AMRR doc",
                  "cr_offset": 1320,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_amrr_base_1": {
                  "description": "Address Match Range Register - Physical Base. Used for Probeless Debug Mode and internal debug. See Silvermont xT HAS AMRR doc. See Silvermont xT HAS Hidden Lake doc",
                  "cr_offset": 1321,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_amrr_mask_0": {
                  "description": "Address Match  Range Register - Physical Mask. Used for Probeless Debug Mode and internal debug. See Silvermont xT HAS AMRR doc",
                  "cr_offset": 1322,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_amrr_mask_1": {
                  "description": "Address Match  Range Register - Physical Mask. Used for Probeless Debug Mode and internal debug. See Silvermont xT HAS AMRR doc",
                  "cr_offset": 1323,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_emrr_base": {
                  "description": "Extended Microcode Range Register - Physical Base",
                  "cr_offset": 1378,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_emrr_mask": {
                  "description": "Extended Microcode Range Register - Physical Mask",
                  "cr_offset": 1379,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_emxrr_base": {
                  "description": "Extended Microcode Executable Range Register - Physical Base",
                  "cr_offset": 1380,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_emxrr_mask": {
                  "description": "Extended Microcode Executable Range Register - Physical Mask",
                  "cr_offset": 1381,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_prmrr_base": {
                  "description": "Protected Memory Range Register - Physical Base",
                  "cr_offset": 1396,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x603f00000e"
            },
            "pmh_cr_prmrr1_base": {
                  "description": "Protected Memory Range Register - Physical Base",
                  "cr_offset": 1336,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_prmrr2_base": {
                  "description": "Protected Memory Range Register - Physical Base",
                  "cr_offset": 1337,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_prmrr3_base": {
                  "description": "Protected Memory Range Register - Physical Base",
                  "cr_offset": 1338,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_prmrr_mask": {
                  "description": "PRotected Memory Range Register - Physical Mask",
                  "cr_offset": 1397,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0xfffffff000400"
            },
            "x86_cr_mtrrdeftype": {
                  "description": ".",
                  "cr_offset": 1407,
                  "numbits": 32,
                  "desired_value": "0x806",
                  "ref_value": "0xc00"
            },
            "x86_cr_mtrrfix16k_80000": {
                  "description": "Maps 128K address range from 80000H-9FFFFH",
                  "cr_offset": 1368,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x606060606060606"
            },
            "x86_cr_mtrrfix16k_a0000": {
                  "description": "Maps 128K address range from A0000H-BFFFFH",
                  "cr_offset": 1369,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrfix4k_c0000": {
                  "description": "Maps 32K address range from C0000H-C7FFFH",
                  "cr_offset": 1384,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrfix4k_c8000": {
                  "description": "Maps 32K address range from C8000H-CFFFFH",
                  "cr_offset": 1385,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrfix4k_d0000": {
                  "description": "Maps 32K address range from D0000H-D7FFFH",
                  "cr_offset": 1386,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrfix4k_d8000": {
                  "description": "Maps 32K address range from D8000H-DFFFFH",
                  "cr_offset": 1387,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrfix4k_e0000": {
                  "description": "Maps 32K address range from E0000H-E7FFFH",
                  "cr_offset": 1388,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrfix4k_e8000": {
                  "description": "Maps 32K address range from E8000H-EFFFFH",
                  "cr_offset": 1389,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrfix4k_f0000": {
                  "description": "Maps 32K address range from F0000H-F7FFFH",
                  "cr_offset": 1390,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrfix4k_f8000": {
                  "description": "Maps 32K address range from F8000H-FFFFFH",
                  "cr_offset": 1391,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrfix64k_00000": {
                  "description": "Maps 512K address range from 0H-7FFFFH",
                  "cr_offset": 1360,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x606060606060606"
            },
            "x86_cr_mtrrphysbase0": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1280,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x100000000006"
            },
            "x86_cr_mtrrphysmask0": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1281,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0xff80000000800"
            },
            "x86_cr_mtrrphysbase1": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1282,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x6"
            },
            "x86_cr_mtrrphysmask1": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1283,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0xff00000000800"
            },
            "x86_cr_mtrrphysbase2": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1284,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x80000000"
            },
            "x86_cr_mtrrphysmask2": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1285,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0xfffff80000800"
            },
            "x86_cr_mtrrphysbase3": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1286,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysmask3": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1287,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysbase4": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1288,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysmask4": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1289,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysbase5": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1290,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysmask5": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1291,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysbase6": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1292,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysmask6": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1293,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysbase7": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1294,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysmask7": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1295,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysbase8": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1296,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysmask8": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1297,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysbase9": {
                  "description": "Refer to Software Developer's Manual",
                  "cr_offset": 1298,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "x86_cr_mtrrphysmask9": {
                  "description": "Refer to Software Developer's Manual.",
                  "cr_offset": 1299,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_seamrr_base": {
                  "description": "SEAM Memory Range Register - IA32_SEAMRR_BASE",
                  "cr_offset": 1340,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_seamrr_mask": {
                  "description": "SEAM Memory Range Register - IA32_SEAMRR_MASK",
                  "cr_offset": 1341,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x400"
            },
            "pmh_cr_fusarr_base": {
                  "description": "Base register for FUSA RR",
                  "cr_offset": 1342,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_fusarr_mask": {
                  "description": "Mask for FUSA RR",
                  "cr_offset": 1343,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_datin0": {
                  "description": "Array DFT DWord 0 Input Register",
                  "cr_offset": 292,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_datin3": {
                  "description": "Array DFT DWord 3 Input Register",
                  "cr_offset": 295,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_datout": {
                  "description": "Data Output Register for array DAT",
                  "cr_offset": 290,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_defeature": {
                  "description": "fill description here",
                  "cr_offset": 259,
                  "numbits": 64,
                  "desired_value": "0x6003c0840c0002",
                  "ref_value": "0x600180840c0002"
            },
            "mec_cr_pdat": {
                  "description": "Primary DAT command, address and data control register. Currently, only Port A is supported; enable bits 27:24 and 31:28 for Ports B and C, respectively",
                  "cr_offset": 288,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_pwrdn_ovrd_dcu": {
                  "description": "fill description here",
                  "cr_offset": 277,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_rtit_info": {
                  "description": "This RTIT creg will tell MEC which TOPA entry to start processing. ucode resets this creg whenever TraceEn transitions from 0->1, before filling up ENTRY0 followed by ENTRY1. MEC H/W updates this when transitioning from one entry to the other while TraceEn is high",
                  "cr_offset": 278,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_rtit_next_table_base": {
                  "description": "This RTIT creg holds the base address of the next ToPA table, written when ToPA trap encounters an entry with END=1. This value will be written to IA32_RTIT_OUTPUT_BASE when the MEC transitions to the next entry, which will be the first entry in that new table.",
                  "cr_offset": 279,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_rtit_topa_entry0": {
                  "description": "This RTIT creg contain all the fields of a ToPA entry 0, plus some additional uarch bits used for communication between ucode and HW.",
                  "cr_offset": 280,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_rtit_topa_entry1": {
                  "description": "This RTIT creg contain all the fields of a ToPA entry 1, plus some additional uarch bits used for communication between ucode and HW.",
                  "cr_offset": 281,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_dctag_fuse": {
                  "description": "Fuse for DCTAG array DFT",
                  "cr_offset": 282,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_dcdata_fuse": {
                  "description": "Fuse  for array DFT",
                  "cr_offset": 283,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_online_repair": {
                  "description": "DCTAG/DCDATA online repair control creg",
                  "cr_offset": 284,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_sdat": {
                  "description": "Secondary command register for array DFT",
                  "cr_offset": 289,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_enq_response": {
                  "description": "MEC AiA EnQ Cmd Response register",
                  "cr_offset": 285,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_monitor_address": {
                  "description": "Setmonitor's physical address",
                  "cr_offset": 291,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_vdm0_cfg": {
                  "description": "VDM0 Creg configurations",
                  "cr_offset": 305,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_vdm0_status": {
                  "description": "VDM0 Creg status",
                  "cr_offset": 306,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_sub_page": {
                  "description": "fill description here",
                  "cr_offset": 1300,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_pwrdn_ovrd_pmh": {
                  "description": "fill description here",
                  "cr_offset": 1301,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_c6dramrr_base": {
                  "description": "C6DRAM Match Range Register - Base ",
                  "cr_offset": 1324,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_c6dramrr_mask": {
                  "description": "C6DRAM Match  Range Register - Physical Mask ",
                  "cr_offset": 1326,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_umrr_base": {
                  "description": "Extended Microcode Range Register - Physical Base",
                  "cr_offset": 1327,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_umrr_mask": {
                  "description": "Extended Microcode Range Register - Physical Mask",
                  "cr_offset": 1328,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_patchmrr_and_abort_page_config": {
                  "description": "This register is used to configure the Patch Memory Range Register (PatchMRR) and the Abort Page.  PatchMRR is used to protect the CRAM during patch-loading and PPPE boot.  PatchMRR will take its address range from the Abort Page (which is 1MB in size) and must take EPT lookup into account.   The MEC will drop all writes that hit the Abort Page and reads will return all 1's.",
                  "cr_offset": 1333,
                  "numbits": 32,
                  "desired_value": "0xfeb000f0",
                  "ref_value": "0xfeb000f0"
            },
            "mec_cr_cache_tlb_info": {
                  "description": "MEC Cache and TLB config info",
                  "cr_offset": 1325,
                  "numbits": 64,
                  "desired_value": "0x400040000300007",
                  "ref_value": "0x400040000300007"
            },
            "mec_cr_stlb_way_mask": {
                  "description": "STLB QOS - Subset of ways into which new STLB entries can allocate",
                  "cr_offset": 1352,
                  "numbits": 32,
                  "desired_value": "0x3f",
                  "ref_value": "0x3f"
            },
            "mec_cr_trigger_i_side_walk": {
                  "description": "STLB QOS - Do an Iside walk for specified LA",
                  "cr_offset": 1353,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "mec_cr_pmh_drain": {
                  "description": "Enable PMH to drain for state update",
                  "cr_offset": 1354,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_priv_kid": {
                  "description": "Private Key ID from VMCS.HKID for TD guest accesses in SEAM non-root mode",
                  "cr_offset": 1357,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ag2_cr_agdtlb_fuse": {
                  "description": "Fuse for array DFT",
                  "cr_offset": 1358,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ag2_cr_online_repair": {
                  "description": "PMHP array online repair control creg",
                  "cr_offset": 1359,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ag2_cr_datin0": {
                  "description": "Array DFT DWord 0 Input Register",
                  "cr_offset": 1316,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ag2_cr_datin3": {
                  "description": "Array DFT DWord 3 Input Register",
                  "cr_offset": 1319,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ag2_cr_datout": {
                  "description": "Data Output Register for array DAT",
                  "cr_offset": 1314,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ag2_cr_sdat": {
                  "description": "Secondary command register for array DFT",
                  "cr_offset": 1313,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ag2_cr_pdat": {
                  "description": "Primary DAT command, address and data control register. Currently, only Port A is supported; enable bits 27:24 and 31:28 for Ports B and C, respectively",
                  "cr_offset": 1312,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "pmh_cr_tdx_pa_mask": {
                  "description": "The PA Bits are masked with this PA MASK. See Gracemont xT HAS TDX/SEAM doc",
                  "cr_offset": 2014,
                  "numbits": 64,
                  "desired_value": "0xfffc000000000",
                  "ref_value": "0xfffc000000000"
            },
            "ag2_cr_tdx_pa_mask": {
                  "description": "The PA Bits are masked with this PA MASK. See Gracemont xT HAS TDX/SEAM doc",
                  "cr_offset": 1374,
                  "numbits": 64,
                  "desired_value": "0xfffc000000000",
                  "ref_value": "0xfffc000000000"
            },
            "arr_cr_datout": {
                  "description": "Array DAT output registers",
                  "cr_offset": 18,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "arr_cr_debug_defeature": {
                  "description": "Debug and Defeature register",
                  "cr_offset": 3,
                  "numbits": 64,
                  "desired_value": "0x200402002200000",
                  "ref_value": "0x402002200000"
            },
            "arr_cr_debug_defeature2": {
                  "description": "Debug and Defeature register",
                  "cr_offset": 6,
                  "numbits": 64,
                  "desired_value": "0x9304000100001f",
                  "ref_value": "0x93041001000000"
            },
            "arr_cr_debug_defeature_reset": {
                  "description": "Debug and Defeature register reset interface",
                  "cr_offset": 19,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "arr_cr_pdat": {
                  "description": "Primary DAT control register. Specifies command, polarity and address. Only command A is used. All unused bits will return 0 on read.",
                  "cr_offset": 16,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "arr_cr_pwrdn_ovrd": {
                  "description": "fill description here",
                  "cr_offset": 55,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x8000480"
            },
            "arr_cr_sdat": {
                  "description": "Secondary DAT cntrol register. Specifies the enable, array select and dword select. ARR supports only one port, hence multi-port information is not used. ARR does not support the sequencer.",
                  "cr_offset": 17,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "arr_cr_debug_defeature3": {
                  "description": "Debug and Defeature register",
                  "cr_offset": 69,
                  "numbits": 64,
                  "desired_value": "0x28400",
                  "ref_value": "0x28400"
            },
            "arr_cr_timed_pebs": {
                  "description": "Timed pebs mclk count creg",
                  "cr_offset": 93,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ia32_cr_pebs_enable": {
                  "description": "Status of Precise Event Based Sampling enables",
                  "cr_offset": 94,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "arr_cr_pebs_status": {
                  "description": "Read-only register to reflect ALLOW_IN_RECORD bits",
                  "cr_offset": 99,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "arr_cr_pebs_bom_in_context_status": {
                  "description": "Read-only register to reflect per counter PEBS_IN_CONTEXT status at BOM",
                  "cr_offset": 101,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "arr_cr_pebs_current_in_context_status": {
                  "description": "Read-only register to reflect per counter current PEBS_IN_CONTEXT status at the time the creg is read.  This creg is kind of a virtual creg (no physical flop) since its data comes from other sources",
                  "cr_offset": 103,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "global_cr_royal_64_isa": {
                  "description": "Control opt in of royal 64 isa features",
                  "cr_offset": 2015,
                  "numbits": 32,
                  "desired_value": "0x2",
                  "ref_value": "0x2"
            },
            "arr1_cr_royal_64_isa": {
                  "description": "Control opt in of royal 64 isa features",
                  "cr_offset": 95,
                  "numbits": 32,
                  "desired_value": "0x2",
                  "ref_value": "0x2"
            },
            "arr1_cr_perfmon_evntsel_aux": {
                  "description": "Perfmon Controls",
                  "cr_offset": 110,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bp_cr_pwrdn_ovrd": {
                  "description": "Unit specific powerdown override register",
                  "cr_offset": 1853,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bp_cr_debug_defeature2": {
                  "description": "fill description here",
                  "cr_offset": 1795,
                  "numbits": 64,
                  "desired_value": "0x206004201fe0080",
                  "ref_value": "0x206004201fe0080"
            },
            "bp_cr_debug_defeature3": {
                  "description": "fill description here",
                  "cr_offset": 1796,
                  "numbits": 64,
                  "desired_value": "0x706861105",
                  "ref_value": "0x706861105"
            },
            "id_cr_patch0": {
                  "description": "Register which determines which macroinstructions will be matched if the enable bit in ID_CR_COMMAND is set. On TNT, patch match register match all decoders, and the patch match uip starts at the first uop of the URAM space",
                  "cr_offset": 1824,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x133ff80007d80"
            },
            "id_cr_patch1": {
                  "description": "Register which determines which macroinstructions will be matched if the enable bit in ID_CR_COMMAND is set. On TNT, patch match register match all decoders, and the patch match uip starts at the first uop of the URAM space",
                  "cr_offset": 1825,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x133ff80007d00"
            },
            "id_cr_patch2": {
                  "description": "Register which determines which macroinstructions will be matched if the enable bit in ID_CR_COMMAND is set. On TNT, patch match register match all decoders, and the patch match uip starts at the first uop of the URAM space",
                  "cr_offset": 1826,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x1b3ffe0807be0"
            },
            "id_cr_patch3": {
                  "description": "Register which determines which macroinstructions will be matched if the enable bit in ID_CR_COMMAND is set. On TNT, patch match register match all decoders, and the patch match uip starts at the first uop of the URAM space",
                  "cr_offset": 1827,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x1b3ffe0007be0"
            },
            "bp_cr_royal_64_isa": {
                  "description": "Control opt in of royal 64 isa features",
                  "cr_offset": 1887,
                  "numbits": 32,
                  "desired_value": "0x2",
                  "ref_value": "0x2"
            },
            "clpu_cr_bpm_trace": {
                  "description": "A change in value of any of the BPM bits should cause a DTF packet to get sent.",
                  "cr_offset": 8723,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "clpu_cr_misc0": {
                  "description": "C6 related misc info for Ucode and MCNT/ACNT registers",
                  "cr_offset": 8740,
                  "numbits": 32,
                  "desired_value": "0xa0000091",
                  "ref_value": "0xa0000099"
            },
            "pm_cr_debug_defeature": {
                  "description": "Debug and Defeature register for perfmon fub",
                  "cr_offset": 8744,
                  "numbits": 32,
                  "desired_value": "0x80",
                  "ref_value": "0x180"
            },
            "clpu_cr_thread_p_req": {
                  "description": "shadow copy of PMA_CR_THREAD_P_REQ.",
                  "cr_offset": 8770,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x11"
            },
            "clpu_cr_hwp_interrupt": {
                  "description": "shadow copy of PMA_CR_HWP_INTERRUPT.",
                  "cr_offset": 8771,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "clpu_cr_hwp_ctrl": {
                  "description": "Regsiter to write into PMA_CR_HWP_REQUEST field HWP_CTL_PACKAGE_CONTROL_PRIORITY. The register is writable only by ucode and can not be read",
                  "cr_offset": 8772,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "clpu_cr_hwp_request_wo_ctrl": {
                  "description": "shadow copy of PMA_CR_HWP_REQUEST. The register is writable only by ucode and can not be read.",
                  "cr_offset": 8784,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "clpu_cr_hwp_request": {
                  "description": "shadow copy of PMA_CR_HWP_REQUEST.",
                  "cr_offset": 8785,
                  "numbits": 64,
                  "desired_value": "0x8000ff01",
                  "ref_value": "0x8000ff01"
            },
            "clpu_cr_core_status": {
                  "description": "Core Status register",
                  "cr_offset": 8794,
                  "numbits": 32,
                  "desired_value": "0x200f07",
                  "ref_value": "0x101"
            },
            "clpu_cr_hgs_debug_obs": {
                  "description": "HGS observation debug reg",
                  "cr_offset": 8795,
                  "numbits": 64,
                  "desired_value": "0x7",
                  "ref_value": "0x7"
            },
            "clpu_cr_hgs_roll_avg": {
                  "description": "Register updated by HW on the specified interval with the rolling average HCNT value. Ucode uses this value to classify the thread type when SW reads HW_FEEDBACK_THREAD MSR. Is writable by ucode to initialize state on thread context switch.",
                  "cr_offset": 8796,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "clpu_cr_hgs_ctrl": {
                  "description": "This register intializes HGS+ logic to preserve some of the history as threads context switch.",
                  "cr_offset": 8806,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "clpu_cr_hgs_hcnt": {
                  "description": "Register updated by HW on the specified interval with the current HCNT value. Ucode read access is enabled for debug.",
                  "cr_offset": 8810,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bus_cr_oobt_policy_cfg": {
                  "description": " Bus creg which is updated by ucode during entry/exit TEE",
                  "cr_offset": 8811,
                  "numbits": 32,
                  "desired_value": "0x7e",
                  "ref_value": "0x7e"
            },
            "biu_cr_reload_cmd": {
                  "description": "Write to this CR will cause the perfmon counter to be automatic reloaded",
                  "cr_offset": 8830,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bus1_cr_perfmon_evntsel_aux": {
                  "description": "Perfmon Controls",
                  "cr_offset": 8814,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bus_cr_pic_core_pm_state_status": {
                  "description": "Does stuff. Should thsi be saved across C6?",
                  "cr_offset": 8877,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x2"
            },
            "bus_cr_pic_tsc": {
                  "description": "TSC = P*CTC + FAST_CNT",
                  "cr_offset": 8897,
                  "numbits": 64,
                  "desired_value": "0x2faa1a1e",
                  "ref_value": "0x17b6a615697038"
            },
            "pic_cr_command": {
                  "description": "This register is actually mixed scope. Bits 7:0 are module; 10:8 are thread scope",
                  "cr_offset": 8907,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bus_cr_dlsm_tracker": {
                  "description": "Contains status bits for dynamic lockstep mode",
                  "cr_offset": 8950,
                  "numbits": 64,
                  "desired_value": "0xa00047080",
                  "ref_value": "0xa00047080"
            },
            "bus_cr_dlsm_clr": {
                  "description": "Dynamic Lockstep Mode Clear register",
                  "cr_offset": 8920,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bus_cr_dlsm_set_and_status": {
                  "description": "Dynamic Lockstep Mode Set and Status Register",
                  "cr_offset": 8921,
                  "numbits": 32,
                  "desired_value": "0x10000",
                  "ref_value": "0x10000"
            },
            "bus2_cr_royal_64_isa": {
                  "description": "Control opt in of royal 64 isa features",
                  "cr_offset": 8927,
                  "numbits": 32,
                  "desired_value": "0x2",
                  "ref_value": "0x2"
            },
            "bnl_cr_tap_misc_core": {
                  "description": "Core registers containing the 32 bits of data for TAP.",
                  "cr_offset": 8989,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_tap_sr0": {
                  "description": "Registers containing the 32 bits of data for TAP.",
                  "cr_offset": 8990,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_tap_sr1": {
                  "description": "Registers containing the 32 bits of data for TAP.",
                  "cr_offset": 8991,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_tap_sr2": {
                  "description": "Registers containing the 32 bits of data for TAP.",
                  "cr_offset": 8992,
                  "numbits": 32,
                  "desired_value": "0xc320",
                  "ref_value": "0xc320"
            },
            "bnl_cr_repair_mecarys0": {
                  "description": "Shadow register for repairable core MEC arrays",
                  "cr_offset": 9012,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_repair_mecarys1": {
                  "description": "Shadow register for repairable core MEC arrays",
                  "cr_offset": 9013,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_repair_fecarys0": {
                  "description": "Shadow register for repairable core FEC arrays",
                  "cr_offset": 9014,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_repair_fecarys1": {
                  "description": "Shadow register for repairable core FEC arrays",
                  "cr_offset": 9015,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_repair_fecarys2": {
                  "description": "Shadow register for repairable core FEC arrays",
                  "cr_offset": 9016,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_repair_fecarys3": {
                  "description": "Shadow register for repairable core FEC arrays",
                  "cr_offset": 9017,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_repair_fecarys4": {
                  "description": "Shadow register for repairable core FEC arrays",
                  "cr_offset": 9018,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_repair_fecarys5": {
                  "description": "Shadow register for repairable core FEC arrays",
                  "cr_offset": 9019,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_repair_fecarys6": {
                  "description": "Shadow register for repairable core FEC arrays",
                  "cr_offset": 9020,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bnl_cr_repair_fecarys7": {
                  "description": "Shadow register for repairable core FEC arrays",
                  "cr_offset": 9021,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ebl_cr_biu_lq_mbe_thresholds": {
                  "description": "Register for L2Q thresholds for MBE level overrides. This is per core per slice",
                  "cr_offset": 9026,
                  "numbits": 32,
                  "desired_value": "0x11122233",
                  "ref_value": "0x11122233"
            },
            "bus_cr_core_idi_setup": {
                  "description": "CR for ucode to change the value of the SAI",
                  "cr_offset": 9095,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x1"
            },
            "ebl_cr_biu_thresholds": {
                  "description": "Register for XQ thresholds and MBE level overrides",
                  "cr_offset": 9104,
                  "numbits": 64,
                  "desired_value": "0x8864298e8",
                  "ref_value": "0x200008864298e8"
            },
            "bus_cr_dynamic_lockstep_ctl": {
                  "description": "Contains control for dynamic lockstep mode (DLSM). ",
                  "cr_offset": 9120,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x1"
            },
            "bus_cr_smi_err_src_status": {
                  "description": "Mixed scope MSR: smi requested by mc0/1/2/3",
                  "cr_offset": 9121,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bus_cr_smi_err_src_reset": {
                  "description": "clear core_smi_err_src_set_and_status",
                  "cr_offset": 9179,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bus_cr_smi_err_src_set": {
                  "description": "set core_smi_err_src_set_and_status",
                  "cr_offset": 9180,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "bus_cr_comparator_error": {
                  "description": "Contains status bits for dynamic lockstep mode miscompares",
                  "cr_offset": 9193,
                  "numbits": 32,
                  "desired_value": "0x80000",
                  "ref_value": "0x80000"
            },
            "fpc_cr_datout": {
                  "description": "Array DAT output register",
                  "cr_offset": 1234,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "fpc_cr_modes_and_defeatures": {
                  "description": "FPC Modes and Defeature Register",
                  "cr_offset": 1157,
                  "numbits": 64,
                  "desired_value": "0x16810100",
                  "ref_value": "0x16810100"
            },
            "fpc_cr_pdat": {
                  "description": "Primary DAT control register. Specifies command, polarity and address. Only command A is used. All unused bits will return 0 on read.",
                  "cr_offset": 1232,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "fpc_cr_pwrdn_ovrd": {
                  "description": "FPC Powerdown Override Register",
                  "cr_offset": 1160,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "fpc_cr_sdat": {
                  "description": "Secondary DAT control register. Specifies the enable, array select and dword select. FPC supports only one port, hence multi-port information is not used. FPC does not support the sequencer.",
                  "cr_offset": 1233,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "fpc_cr_scmisr_result_0": {
                  "description": "CR connection to FPAP SCMISR result data",
                  "cr_offset": 1159,
                  "numbits": 32,
                  "desired_value": "0xa0",
                  "ref_value": "0x19"
            },
            "ic_cr_datout": {
                  "description": "fill description here",
                  "cr_offset": 1586,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_poison_go_err_pa": {
                  "description": "This creg is a way for ucode to read the Physical Address associated with a poison/go_err",
                  "cr_offset": 1536,
                  "numbits": 64,
                  "desired_value": "0xa4c0",
                  "ref_value": "0x6d4f9cc0"
            },
            "ic_cr_debug_defeature": {
                  "description": "fill description here",
                  "cr_offset": 1595,
                  "numbits": 64,
                  "desired_value": "0x400024000000000c",
                  "ref_value": "0x400024000000000c"
            },
            "ic_cr_debug_defeature2": {
                  "description": "Additional debug defeature register for handling more defeatures cases from TNT",
                  "cr_offset": 1537,
                  "numbits": 64,
                  "desired_value": "0xc000000001080000",
                  "ref_value": "0xc002000001090000"
            },
            "ic_cr_debug_defeature3": {
                  "description": "Additional debug defeature register for handling more defeatures ",
                  "cr_offset": 1538,
                  "numbits": 64,
                  "desired_value": "0x4000000006000000",
                  "ref_value": "0x4000000006000000"
            },
            "ic_cr_debug_defeature4": {
                  "description": "Additional debug defeature register for handling more defeatures ",
                  "cr_offset": 1539,
                  "numbits": 64,
                  "desired_value": "0x442c19b0",
                  "ref_value": "0x442c19b0"
            },
            "ic_cr_debug_defeature5": {
                  "description": "Additional debug defeature register for handling more defeatures ",
                  "cr_offset": 1540,
                  "numbits": 64,
                  "desired_value": "0x810400",
                  "ref_value": "0x810400"
            },
            "ic_cr_fec_cr_scmisr_result_0": {
                  "description": "This is read only creg. It reads data from scmisr flop and muxes it for ucode read.",
                  "cr_offset": 1541,
                  "numbits": 32,
                  "desired_value": "0xc8",
                  "ref_value": "0x0"
            },
            "ic_cr_code_brkpt_mask": {
                  "description": "New register for masking code breakpoint address match",
                  "cr_offset": 1542,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_cache_itlb_mspatch_info": {
                  "description": " CPUid for ictlb ",
                  "cr_offset": 1543,
                  "numbits": 64,
                  "desired_value": "0x8000027f",
                  "ref_value": "0x8000027f"
            },
            "ic_cr_pdat": {
                  "description": "fill description here",
                  "cr_offset": 1584,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_pwrdn_ovrd": {
                  "description": "fill description here",
                  "cr_offset": 1596,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_sdat": {
                  "description": "fill description here",
                  "cr_offset": 1585,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_itlb_lg_pg_ctl": {
                  "description": "fill description here",
                  "cr_offset": 1598,
                  "numbits": 32,
                  "desired_value": "0xff0",
                  "ref_value": "0xff0"
            },
            "ic_cr_mode_based_target_key": {
                  "description": "Mode Based Target Key",
                  "cr_offset": 1548,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0xcaf8868a"
            },
            "ic_cr_online_repair": {
                  "description": "New register for ICU in-field array repair control",
                  "cr_offset": 1549,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icdata_infield_repair": {
                  "description": "Fuse for ICDATA array DFT",
                  "cr_offset": 1550,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icbtb_target_infield_repair": {
                  "description": "Fuse for IC BTB TARGET array DFT",
                  "cr_offset": 1551,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icbtb_ctl_infield_repair": {
                  "description": "Fuse for IC BTB WAY array DFT",
                  "cr_offset": 1553,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icglob0_infield_repair": {
                  "description": "Fuse for IC GLOB0 array DFT",
                  "cr_offset": 1554,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icglob1_infield_repair": {
                  "description": "Fuse for IC GLOB1 array DFT",
                  "cr_offset": 1555,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icglob2_infield_repair": {
                  "description": "Fuse for IC GLOB2 array DFT",
                  "cr_offset": 1556,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icglob3_infield_repair": {
                  "description": "Fuse for IC GLOB3 array DFT",
                  "cr_offset": 1557,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icglob4_infield_repair": {
                  "description": "Fuse for IC GLOB4 array DFT",
                  "cr_offset": 1558,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icglob5_infield_repair": {
                  "description": "Fuse for IC GLOB5 array DFT",
                  "cr_offset": 1559,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icipred0_infield_repair": {
                  "description": "Fuse for IC IPRED0 array DFT",
                  "cr_offset": 1560,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icipred1_infield_repair": {
                  "description": "Fuse for IC IPRED1 array DFT",
                  "cr_offset": 1561,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icipred2_infield_repair": {
                  "description": "Fuse for IC IPRED2 array DFT",
                  "cr_offset": 1562,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icipred3_infield_repair": {
                  "description": "Fuse for IC IPRED3 array DFT",
                  "cr_offset": 1563,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icnlp_infield_repair": {
                  "description": "Fuse for IC NLP array DFT",
                  "cr_offset": 1564,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_icpd_infield_repair": {
                  "description": "Fuse for ICPD array DFT",
                  "cr_offset": 1568,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ic_cr_ic_post_si_debug_data_4ucode": {
                  "description": "Additional read only register for helping ucode in post-si debug",
                  "cr_offset": 1569,
                  "numbits": 64,
                  "desired_value": "0x668073",
                  "ref_value": "0x315955"
            },
            "iec_cr_datout": {
                  "description": "Array DAT output register",
                  "cr_offset": 1106,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_debug_defeature_array_frz": {
                  "description": "fill description here",
                  "cr_offset": 1036,
                  "numbits": 64,
                  "desired_value": "0x190000040000",
                  "ref_value": "0x192000040000"
            },
            "iec_cr_pdat": {
                  "description": "Primary DAT control register. Specifies command, polarity and address. Only command A is used. All unused bits will return 0 on read.",
                  "cr_offset": 1104,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_pwrdn_ovrd": {
                  "description": "Powerdown override creg. One bit for each FUB in IEC.",
                  "cr_offset": 1041,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x100000"
            },
            "iec_cr_sdat": {
                  "description": "Secondary DAT cntrol register. Specifies the enable, array select and dword select. IEC supports only one port, hence multi-port information is not used. IEC does not support the sequencer.",
                  "cr_offset": 1105,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_key_cache_lookup_5": {
                  "description": "key cache data",
                  "cr_offset": 1034,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_key_cache_lookup_4": {
                  "description": "key cache data",
                  "cr_offset": 1033,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_key_cache_lookup_3": {
                  "description": "key cache data",
                  "cr_offset": 1032,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_key_cache_lookup_2": {
                  "description": "key cache data",
                  "cr_offset": 1031,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_key_cache_lookup_1": {
                  "description": "key cache data",
                  "cr_offset": 1030,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_key_cache_lookup_0": {
                  "description": "key cache data",
                  "cr_offset": 1029,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_key_cache_misc": {
                  "description": "key cache ctrl",
                  "cr_offset": 1025,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "iec_cr_scmisr_result_0": {
                  "description": "This is read only creg. It reads data from IECP scmisr flop and muxes it for ucode read.",
                  "cr_offset": 1035,
                  "numbits": 32,
                  "desired_value": "0xf0",
                  "ref_value": "0x2"
            },
            "iec_cr_scmisr_result_1": {
                  "description": "This is read only creg. It reads data from RSVP scmisr flop and muxes it for ucode read.",
                  "cr_offset": 1037,
                  "numbits": 32,
                  "desired_value": "0x63",
                  "ref_value": "0x6"
            },
            "iec_cr_royal_64_isa": {
                  "description": "Control opt in of royal 64 isa features",
                  "cr_offset": 1119,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ms_cr_datin1": {
                  "description": "fill description here",
                  "cr_offset": 1701,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ms_cr_datout": {
                  "description": "fill description here",
                  "cr_offset": 1698,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ms_cr_status_indication": {
                  "description": "To capture and indicate the status of particular signals ",
                  "cr_offset": 1664,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ms_cr_last_taken_patch": {
                  "description": "To capture the match uip and target uip of the last taken patch match ",
                  "cr_offset": 1665,
                  "numbits": 64,
                  "desired_value": "0xa04926ad",
                  "ref_value": "0xa4a0510c"
            },
            "ms_cr_patch_config": {
                  "description": "ms patch enable configuration register",
                  "cr_offset": 1666,
                  "numbits": 32,
                  "desired_value": "0x2",
                  "ref_value": "0x0"
            },
            "ms_cr_debug_defeature": {
                  "description": "Debug and Defeature register for MS1 ccb",
                  "cr_offset": 1682,
                  "numbits": 32,
                  "desired_value": "0x129e020",
                  "ref_value": "0x129e000"
            },
            "ms_cr_pwrdn_ovrd": {
                  "description": "Powerdown Override for MS1 ccb",
                  "cr_offset": 1667,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ms_cr_pdat": {
                  "description": "fill description here",
                  "cr_offset": 1696,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ms_cr_sdat": {
                  "description": "fill description here",
                  "cr_offset": 1697,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ms_cr_uncorr_status": {
                  "description": "Register to log if any Uncorrectable errors were detected in the MS",
                  "cr_offset": 1683,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ms_cr_corr_status": {
                  "description": "Register to log if any correctable errors were detected in the MS.This register will be reset on cold and warm reset but on C6 it will be saved and restored",
                  "cr_offset": 1669,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ms_cr_core_fuse_values_0": {
                  "description": "stash various core fuse values read from ERI. Populated by reset microcode.",
                  "cr_offset": 1670,
                  "numbits": 64,
                  "desired_value": "0xf5b09a466",
                  "ref_value": "0xf68bebb93ba6"
            },
            "ms1_cr_tdx_pa_mask": {
                  "description": "The PA Bits are masked with this PA MASK. See Gracemont xT HAS TDX/SEAM doc",
                  "cr_offset": 1758,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_addr0_a": {
                  "description": "Used to configure RTIT IP filtering and Tracestop regions.  This MSR defines the base LIP for the region defined as ADDR0.",
                  "cr_offset": 128,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_addr0_b": {
                  "description": "Used to configure IP filtering and Tracestop regions.  This MSR defines the limit LIP for region defined as ADDR0.",
                  "cr_offset": 129,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_addr1_a": {
                  "description": "Used to configure RTIT IP filtering and Tracestop regions.  This MSR defines the base LIP for the region defined as ADDR1.",
                  "cr_offset": 130,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_addr1_b": {
                  "description": "Used to configure IP filtering and Tracestop regions.  This MSR defines the limit LIP for region defined as ADDR1.",
                  "cr_offset": 131,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_status": {
                  "description": "RTIT Status Register",
                  "cr_offset": 177,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_trigger0_cfg": {
                  "description": "PTTT Config1",
                  "cr_offset": 138,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_trigger1_cfg": {
                  "description": "PTTT Config1",
                  "cr_offset": 139,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bnl_cr_u_cet": {
                  "description": "Linear address of the user mode top of shadow stack pointer to be loaded into SSP on next supervisor to user mode transition. Must be machine canonical and the address must be aligned to 4 bytes i.e. bits 1:0 are reserved",
                  "cr_offset": 18412,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bnl_cr_s_cet": {
                  "description": "Linear address of the user mode top of shadow stack pointer to be loaded into SSP on next user to supervisor mode transition. Must be machine canonical and the address must be aligned to 4 bytes i.e. bits 1:0 are reserved",
                  "cr_offset": 18413,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.glm_cr_rtit_ctl": {
                  "description": "This is the RTIT Control Register used to control RTIT features",
                  "cr_offset": 2032,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_depth": {
                  "description": "Last Branch Record maximum stack depth register ",
                  "cr_offset": 39,
                  "numbits": 32,
                  "desired_value": "0x20",
                  "ref_value": "0x20"
            },
            "thread0.arr_cr_lbr_misc": {
                  "description": "Last Branch Record Count. COUNT[7:0] field increments when an LBR is recorded, and decrements when a RET \"pops\" an LBR entry in call-stack mode. Unlike LBR_TOS this COUNT field is in no way tied to the microarchitecture, and hence doesn't impact a branch's placement in the LBR array.  ",
                  "cr_offset": 40,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_tmpdr6": {
                  "description": "Register which contains data breakpoint state for pending data breakpoints. It is cleared by the ROB when a ClearTMPDR6 flow marker is retired. It is writ- ten by the FPEH micro-code to correctly setup the match bits when an FLD m64/32real macroinstruction that enters it is also the target of a data breakpoint. The Exact Match micro-code copies this register to DR6. micro-code must ensure that this register is not written at the same time as a microinstruction which contains a ClearTMPDR6 or EvalTFBit flow marker is retiring. micro-code must also ensure that this register is not written at the same time as a microinstruction capable of hitting a data breakpoint is retiring",
                  "cr_offset": 28,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rar_control": {
                  "description": "RAR control MSR ",
                  "cr_offset": 90,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_ctl": {
                  "description": "Last Branch Record enabling and configuration register ",
                  "cr_offset": 18365,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc2": {
                  "description": "General purpose counter 2",
                  "cr_offset": 8808,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc3": {
                  "description": "General purpose counter 3",
                  "cr_offset": 8812,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc4": {
                  "description": "General purpose counter 4",
                  "cr_offset": 8816,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc5": {
                  "description": "General purpose counter 5",
                  "cr_offset": 8820,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc6": {
                  "description": "General purpose counter 6",
                  "cr_offset": 8824,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc7": {
                  "description": "General purpose counter 7",
                  "cr_offset": 8828,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr1": {
                  "description": "Fixed PerfMon counter 1 - Unhalted core cycles.",
                  "cr_offset": 8805,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr2": {
                  "description": "Fixed PerfMon counter 2 - Unhalted core cycles.",
                  "cr_offset": 8809,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr4": {
                  "description": "Fixed PerfMon counter 4 - Unhalted core cycles.",
                  "cr_offset": 8817,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr5": {
                  "description": "Fixed PerfMon counter 5 - Unhalted core cycles.",
                  "cr_offset": 8821,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr6": {
                  "description": "Fixed PerfMon counter 6 - Unhalted core cycles.",
                  "cr_offset": 8825,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perf_global_status": {
                  "description": "PerfMon Global Status Register. This MSR is read only; uCode generates #GP on any write.",
                  "cr_offset": 8718,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perf_global_status_reset": {
                  "description": "Global Perfmon Overflow clear register. This creg is write only; read value is irrelevant for the RDMSR. For some reason, this MSR is not a write only MSR. Return 0s on reads",
                  "cr_offset": 8720,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perf_global_status_set": {
                  "description": "PerfMon Arch v4 register used to enumerate the availability of PerfMon resources for use. Ucode will not read this creg, so its behavior on reads is a don't care.",
                  "cr_offset": 8721,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perf_unavailable_status": {
                  "description": "PerfMon Arch v4 register used to enumerate the availability of PerfMon resources for use",
                  "cr_offset": 8722,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmg_cr_pst_acnt": {
                  "description": "fill description here",
                  "cr_offset": 8774,
                  "numbits": 64,
                  "desired_value": "0x221f",
                  "ref_value": "0xadd32fdb0ec"
            },
            "thread0.pmg_cr_pst_mcnt": {
                  "description": "fill description here",
                  "cr_offset": 8807,
                  "numbits": 64,
                  "desired_value": "0x880",
                  "ref_value": "0xadd0fbfe0f0"
            },
            "thread0.pmg_cr_pst_pcnt": {
                  "description": "productivity cycles counter (HWP)",
                  "cr_offset": 8773,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x42e8880b573"
            },
            "thread0.ia32_cr_pmc2_reload_cfg": {
                  "description": "GP counter reload configuration register",
                  "cr_offset": 8813,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc3_reload_cfg": {
                  "description": "GP counter reload configuration register",
                  "cr_offset": 8815,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc4_reload_cfg": {
                  "description": "GP counter reload configuration register",
                  "cr_offset": 8818,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc5_reload_cfg": {
                  "description": "GP counter reload configuration register",
                  "cr_offset": 8819,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc6_reload_cfg": {
                  "description": "GP counter reload configuration register",
                  "cr_offset": 8822,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc7_reload_cfg": {
                  "description": "GP counter reload configuration register",
                  "cr_offset": 8823,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr0_reload_cfg": {
                  "description": "Fixed counter reload configuration register",
                  "cr_offset": 8826,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr1_reload_cfg": {
                  "description": "Fixed counter reload configuration register",
                  "cr_offset": 8829,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bnl_cr_debugctlmsr": {
                  "description": "Register used to enable various documented and undocumented debug features. See PPro Developer-s Manual, Vol. 3 for more information on the public features. .",
                  "cr_offset": 26619,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr0": {
                  "description": "Fixed PerfMon counter 0 - Instructions retired.",
                  "cr_offset": 10209,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perf_global_ctrl": {
                  "description": "Global Perfmon Enable/Disable register",
                  "cr_offset": 10159,
                  "numbits": 64,
                  "desired_value": "0xff",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel0": {
                  "description": "perf event selector for general counter 0",
                  "cr_offset": 10183,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel1": {
                  "description": "perf event selector for general counter 1",
                  "cr_offset": 10184,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel2": {
                  "description": "perf event selector for general counter 2",
                  "cr_offset": 10185,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel3": {
                  "description": "perf event selector for general counter 3",
                  "cr_offset": 10186,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel4": {
                  "description": "perf event selector for general counter 4",
                  "cr_offset": 10187,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel5": {
                  "description": "perf event selector for general counter 5",
                  "cr_offset": 10188,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel6": {
                  "description": "perf event selector for general counter 6",
                  "cr_offset": 10189,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel7": {
                  "description": "perf event selector for general counter 7",
                  "cr_offset": 10190,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel0_ext": {
                  "description": "Extended Perf event selctor for GP counter 0",
                  "cr_offset": 10194,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel1_ext": {
                  "description": "Extended Perf event selctor for GP counter 1",
                  "cr_offset": 10195,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel2_ext": {
                  "description": "Extended Perf event selctor for GP counter 2",
                  "cr_offset": 10196,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel3_ext": {
                  "description": "Extended Perf event selctor for GP counter 3",
                  "cr_offset": 10197,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel4_ext": {
                  "description": "Extended Perf event selctor for GP counter 4",
                  "cr_offset": 10198,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel5_ext": {
                  "description": "Extended Perf event selctor for GP counter 5",
                  "cr_offset": 10199,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel6_ext": {
                  "description": "Extended Perf event selctor for GP counter 6",
                  "cr_offset": 10200,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perfevtsel7_ext": {
                  "description": "Extended Perf event selctor for GP counter 7",
                  "cr_offset": 10201,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc0": {
                  "description": "General purpose counter 0. This was changed to a global creg on GLM for the sake of PEBS PDIR. BUS1 needs to also support reads of the local address (BUS1_CR_PMC0) for the sake of the RDPMC macro instruction.",
                  "cr_offset": 10208,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pmc1": {
                  "description": "General purpose counter 1. This was changed to a global creg on GLM for the sake of PEBS PDIR. BUS1 needs to also support reads of the local address (BUS1_CR_PMC1) for the sake of the RDPMC macro instruction.",
                  "cr_offset": 10212,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr_ctrl": {
                  "description": "Global Perfmon Overflow clear register. BIU HW will clear the corresponding overflow in 38:32 of PERF_GLOBAL_STATUS if there is any change in value of bits 27:0 (Each 4 bit field affects its corresponding overflow).",
                  "cr_offset": 10125,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr0_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 0",
                  "cr_offset": 10133,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr1_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 1",
                  "cr_offset": 10134,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr2_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 2",
                  "cr_offset": 10135,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr4_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 4",
                  "cr_offset": 10137,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr5_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 5",
                  "cr_offset": 10138,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_fixed_ctr6_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 6",
                  "cr_offset": 10139,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bnl_cr_icectlpmr": {
                  "description": "Register which contains control and status bits related to probe mode. This register is only accessible when the Processor is in probe mode. micro-code uses this register to communicate with the probe mode software.",
                  "cr_offset": 9055,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bnl_cr_pdr_high": {
                  "description": "Registers used by probe mode software to communicate architectural state between the probe mode software and the processor. The MSRs are only visible in probe mode.",
                  "cr_offset": 8986,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bnl_cr_pdr_low": {
                  "description": "Registers used by probe mode software to communicate architectural state between the probe mode software and the processor. The MSRs are only visible in probe mode.",
                  "cr_offset": 8987,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.slm_cr_debug_resource_status": {
                  "description": "Not a real register. This define exists to create the MSR routine that will be used to return the status of debug resources. These bits used to exist in MISC_ENABLES but they were moved to this new MSR (CART: 7/13/06:Nehalem i355197).",
                  "cr_offset": 9023,
                  "numbits": 32,
                  "desired_value": "0x3",
                  "ref_value": "0x3"
            },
            "thread0.pic_cr_pic_self_ipi": {
                  "description": "fill description here",
                  "cr_offset": 8895,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_error_status": {
                  "description": "Skylake only defines bits 7:4, and GP faults on all non-zero writes.",
                  "cr_offset": 8911,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_extended_local_apic_id": {
                  "description": "PIC Logical APIC ID register",
                  "cr_offset": 8834,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_extended_logical_destination": {
                  "description": "fill description here",
                  "cr_offset": 8845,
                  "numbits": 32,
                  "desired_value": "0x1",
                  "ref_value": "0x1"
            },
            "thread0.pic_cr_pic_interrupt_command": {
                  "description": "fill description here",
                  "cr_offset": 8912,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0xc0687"
            },
            "thread0.pic_cr_pic_local_unit_version": {
                  "description": "fill description here",
                  "cr_offset": 8835,
                  "numbits": 32,
                  "desired_value": "0x1060015",
                  "ref_value": "0x1060015"
            },
            "thread0.pic_cr_pic_lvt_dlsm": {
                  "description": "The original DLSM specification describes delivery of an NMI to the active core when a DLSM SEVT break event occurs. A DLSM SEVT break event occurs when deactivation happens in response to targeted shadow core events or some broadcast events (SMIs, NMIs, MCERRs). The purpose of this message is to tell active core software that it is no longer protected by lockstep. Late customer feedback from some customers is that they want more flexibility than just an NMI for this event. We are also motivated to fit into the NMI source ID mechanism that FRED allows for, which is available in DKT.",
                  "cr_offset": 8913,
                  "numbits": 32,
                  "desired_value": "0x10000",
                  "ref_value": "0x10000"
            },
            "thread0.pic_cr_pic_lvt_cmci": {
                  "description": "fill description here",
                  "cr_offset": 8914,
                  "numbits": 32,
                  "desired_value": "0x10000",
                  "ref_value": "0x10000"
            },
            "thread0.pic_cr_pic_lvt_error": {
                  "description": "fill description here",
                  "cr_offset": 8887,
                  "numbits": 32,
                  "desired_value": "0x10000",
                  "ref_value": "0x10000"
            },
            "thread0.pic_cr_pic_lvt_lint0": {
                  "description": "fill description here",
                  "cr_offset": 8885,
                  "numbits": 32,
                  "desired_value": "0x10000",
                  "ref_value": "0x700"
            },
            "thread0.pic_cr_pic_lvt_lint1": {
                  "description": "fill description here",
                  "cr_offset": 8886,
                  "numbits": 32,
                  "desired_value": "0x10000",
                  "ref_value": "0x400"
            },
            "thread0.pic_cr_pic_lvt_perf": {
                  "description": "fill description here",
                  "cr_offset": 8884,
                  "numbits": 32,
                  "desired_value": "0x10000",
                  "ref_value": "0x10000"
            },
            "thread0.pic_cr_pic_lvt_therm": {
                  "description": "fill description here",
                  "cr_offset": 8883,
                  "numbits": 32,
                  "desired_value": "0x10000",
                  "ref_value": "0x10000"
            },
            "thread0.pic_cr_pic_lvt_timer": {
                  "description": "fill description here",
                  "cr_offset": 8882,
                  "numbits": 32,
                  "desired_value": "0x10000",
                  "ref_value": "0x20005"
            },
            "thread0.pic_cr_pic_processor_priority": {
                  "description": "fill description here",
                  "cr_offset": 8842,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_spurious_interrupt": {
                  "description": "fill description here",
                  "cr_offset": 8847,
                  "numbits": 32,
                  "desired_value": "0x1ff",
                  "ref_value": "0x10f"
            },
            "thread0.pic_cr_pic_task_priority": {
                  "description": "fill description here",
                  "cr_offset": 8840,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_timer_current_count_reg": {
                  "description": "This corresponds to the value in the Current Count Register CCR in the APIC.",
                  "cr_offset": 8953,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0xa7fd16b9"
            },
            "thread0.pic_cr_pic_timer_divide_config_reg": {
                  "description": "This corresponds to the value in the Divide Config Register in the APIC.",
                  "cr_offset": 8894,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_timer_initial_count_reg": {
                  "description": "This corresponds to the value in the Initial Count Register in the APIC.",
                  "cr_offset": 8888,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0xffffffff"
            },
            "thread0.ia32_cr_qos_core_bw_thrtl_0": {
                  "description": "MBE levels based on CLOS for bandwidth throttling",
                  "cr_offset": 9110,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_qos_core_bw_thrtl_1": {
                  "description": "MBE levels based on CLOS for bandwidth throttling",
                  "cr_offset": 9111,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_pqr_assoc": {
                  "description": "Class Of Service Configuration Register",
                  "cr_offset": 9119,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_resource_priority": {
                  "description": "Class Of Service Resource Priority Feature Configuration",
                  "cr_offset": 9177,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_code_prefetch_ctl": {
                  "description": "Code Prefetch Number of Cachelines, Cluster Offline, Predecode, and BTB Controls",
                  "cr_offset": 1800,
                  "numbits": 64,
                  "desired_value": "0x8184848484",
                  "ref_value": "0x8184848484"
            },
            "thread0.bnl_cr_cpl": {
                  "description": "        which contain the privilege level of the currently executing process    (CPL). Micro-code must update this register any time the privilege",
                  "cr_offset": 1950,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_mci_misc": {
                  "description": "MCA MISC Register. WRMSR uCode generates #GP on non-zero writes. Skylake i1350467: Allow WRMSR to update all bits if PPPE_ACTIVE. GLM i1958673 (Microserver MCA Enhancements):Allow WRMSR to update all bits if DEBUG_ERR_INJ_CTL.MCBW_E",
                  "cr_offset": 260,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_mcg_contain": {
                  "description": "Register that contains the poison and (not on Atom) viral bit valid / invalid state",
                  "cr_offset": 266,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x1"
            },
            "thread0.mec_cr_pebs_ld_lat_threshold": {
                  "description": "Load Latency Threshold",
                  "cr_offset": 304,
                  "numbits": 64,
                  "desired_value": "0x3",
                  "ref_value": "0x3"
            },
            "thread0.ia32_cr_efer": {
                  "description": "Architectural EFER MSR.",
                  "cr_offset": 18431,
                  "numbits": 32,
                  "desired_value": "0x800",
                  "ref_value": "0xd00"
            },
            "thread0.x86_cr_apicbase": {
                  "description": "Register used to implement the APICBASE MSR. Contains the base address for all the APIC registers along with certain APIC control and state bits.",
                  "cr_offset": 1979,
                  "numbits": 64,
                  "desired_value": "0xfee00800",
                  "ref_value": "0xfee00d00"
            },
            "thread0.pmh_cr_pkrs": {
                  "description": "Holds 16 pairs of AD and WD using protection key rights checks for OS",
                  "cr_offset": 1305,
                  "numbits": 32,
                  "desired_value": "0xfffffffc",
                  "ref_value": "0x0"
            },
            "thread0.agu_cr_pdptr0": {
                  "description": "Registers containing the page directory pointers 0 used by the PMH to support Mode C paging.",
                  "cr_offset": 1344,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x71510001"
            },
            "thread0.agu_cr_pdptr1": {
                  "description": "Registers containing the page directory pointers 1 used by the PMH to support Mode C paging.",
                  "cr_offset": 1345,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x7150f001"
            },
            "thread0.agu_cr_pdptr2": {
                  "description": "Registers containing the page directory pointers 2used by the PMH to support Mode C paging.",
                  "cr_offset": 1346,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x7150e001"
            },
            "thread0.agu_cr_pdptr3": {
                  "description": "Registers containing the page directory pointers 3 used by the PMH to support Mode C paging.",
                  "cr_offset": 1347,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x7150d001"
            },
            "thread0.pmh_cr_elsrr_base": {
                  "description": "Enclave Linear Address Region - Linear Base",
                  "cr_offset": 1365,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmh_cr_elsrr_mask": {
                  "description": "Enclave Linear Address Region - Linear Mask",
                  "cr_offset": 1366,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmh_cr_eptp": {
                  "description": "Extended Page Table Pointer",
                  "cr_offset": 1308,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.x86_cr_pat": {
                  "description": "Register containing the lower 8 bytes of the MAP (Memory Attribute Palette).",
                  "cr_offset": 1383,
                  "numbits": 64,
                  "desired_value": "0x7040600070406",
                  "ref_value": "0x7040600070406"
            },
            "thread0.glm_cr_se": {
                  "description": "SE State bits",
                  "cr_offset": 2001,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.agu_cr_lt_physical_ldst_info": {
                  "description": "Micro-code register used to store memtype of physical load/store uops for LT. This register will probably be removed for SLM in phase 4.",
                  "cr_offset": 256,
                  "numbits": 32,
                  "desired_value": "0x1",
                  "ref_value": "0x1"
            },
            "thread0.mec_cr_mc_error_inject": {
                  "description": "Register containing additional machine check information.",
                  "cr_offset": 262,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_mc_info": {
                  "description": "Register containing additional machine check\ninformation.",
                  "cr_offset": 263,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_shadow_mca": {
                  "description": "Register containing shadow of fault like MCA information.",
                  "cr_offset": 264,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_commands": {
                  "description": "Register to cause ucode based actions in MEC.",
                  "cr_offset": 265,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_si_debug_cfg0": {
                  "description": "Config register for Silicon debug",
                  "cr_offset": 271,
                  "numbits": 64,
                  "desired_value": "0x80000000000",
                  "ref_value": "0x80000000000"
            },
            "thread0.mec_cr_prefetch_cfg": {
                  "description": "Config register for Prefetchers",
                  "cr_offset": 272,
                  "numbits": 64,
                  "desired_value": "0xc118be3",
                  "ref_value": "0xc118be3"
            },
            "thread0.mec_cr_modes_and_defeatures": {
                  "description": "fill description here",
                  "cr_offset": 261,
                  "numbits": 64,
                  "desired_value": "0x4600000000000011",
                  "ref_value": "0x4600000002000010"
            },
            "thread0.mec_cr_modes_and_defeatures2": {
                  "description": "fill description here",
                  "cr_offset": 273,
                  "numbits": 64,
                  "desired_value": "0x3440580000",
                  "ref_value": "0x3440580000"
            },
            "thread0.mec_cr_modes_and_defeatures3": {
                  "description": "fill description here",
                  "cr_offset": 274,
                  "numbits": 64,
                  "desired_value": "0x80228000201800",
                  "ref_value": "0x20228000205800"
            },
            "thread0.mec_cr_post_si_defeatures": {
                  "description": "fill description here",
                  "cr_offset": 275,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_wcb_widget": {
                  "description": " A creg for wcb widget that can write specific data \u00e2\u0080\u0093 for now zeros or ones \u00e2\u0080\u0093 to a desired location, for a specific length",
                  "cr_offset": 276,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_pebs_dla": {
                  "description": "Data Linear Address for PEBs",
                  "cr_offset": 300,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_fla": {
                  "description": "Linear Address for the last FP load for X87",
                  "cr_offset": 301,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_pebs_ld_latency_lfsr": {
                  "description": "Load Latency LFSR",
                  "cr_offset": 302,
                  "numbits": 64,
                  "desired_value": "0x155",
                  "ref_value": "0x155"
            },
            "thread0.mec_cr_pebs_ld_latency": {
                  "description": "Load Latency Information",
                  "cr_offset": 303,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_scmisr_result_0": {
                  "description": "SCMISR Result data for ucode read. It reads data from scmisr flop and muxes it for ucode read.",
                  "cr_offset": 307,
                  "numbits": 32,
                  "desired_value": "0x71",
                  "ref_value": "0x1fc"
            },
            "thread0.bnl_cr_cs_l_d_bits": {
                  "description": "        which contain the CS L and D bit. uCode usee this creg to       broadcast L and D bit.",
                  "cr_offset": 18421,
                  "numbits": 32,
                  "desired_value": "0x4000",
                  "ref_value": "0x2000"
            },
            "thread0.ia32_cr_efer_lma_lme": {
                  "description": "Architectural EFER MSR. LMA LME partial write",
                  "cr_offset": 18406,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.x86_cr_dr0": {
                  "description": "Architectural DR0 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 1960,
                  "numbits": 64,
                  "desired_value": "0xaced",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.x86_cr_dr1": {
                  "description": "Architectural DR1 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 1961,
                  "numbits": 64,
                  "desired_value": "0x8000000000000000",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.x86_cr_dr2": {
                  "description": "Architectural DR2 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 1962,
                  "numbits": 64,
                  "desired_value": "0x800000000000010d",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.x86_cr_dr3": {
                  "description": "Architectural DR3 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 1963,
                  "numbits": 64,
                  "desired_value": "0x800000000000ca82",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.x86_cr_dr7": {
                  "description": "Architectural DR7 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 2040,
                  "numbits": 64,
                  "desired_value": "0x400",
                  "ref_value": "0x400"
            },
            "thread0.ag1_cr_sys_flags": {
                  "description": "       bit 0-7 and bit 11 zero out in BNL. cr_sys_flags_mnnnh[10:8] was removed        from the RTL signal path for c6 state checker purposes ... it is still",
                  "cr_offset": 16758,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_debugctlmsr": {
                  "description": "Register used to enable various documented and undocumented debug features. See PPro Developer-s Manual, Vol. 3 for more information on the public features. .",
                  "cr_offset": 16763,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_perfevtsel0": {
                  "description": "perf event selector for general counter 0",
                  "cr_offset": 327,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_perfevtsel1": {
                  "description": "perf event selector for general counter 1",
                  "cr_offset": 328,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_perfevtsel2": {
                  "description": "perf event selector for general counter 2",
                  "cr_offset": 329,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_perfevtsel3": {
                  "description": "perf event selector for general counter 3",
                  "cr_offset": 330,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_perfevtsel4": {
                  "description": "perf event selector for general counter 4",
                  "cr_offset": 331,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_perfevtsel5": {
                  "description": "perf event selector for general counter 5",
                  "cr_offset": 332,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_perfevtsel6": {
                  "description": "perf event selector for general counter 6",
                  "cr_offset": 333,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_perfevtsel7": {
                  "description": "perf event selector for general counter 7",
                  "cr_offset": 334,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_crosscluster_debug_defeature": {
                  "description": "debug defeature to disable cross cluster or unit feature from DKT",
                  "cr_offset": 319,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_cpl": {
                  "description": "        which contain the privilege level of the currently executing process    (CPL). Micro-code must update this register any time the privilege",
                  "cr_offset": 286,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_vmx_clr": {
                  "description": "Clear VMX register",
                  "cr_offset": 287,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_cs_l_d_bits": {
                  "description": "        which contain the CS L and D bit. uCode usee this creg to       broadcast L and D bit.",
                  "cr_offset": 16757,
                  "numbits": 32,
                  "desired_value": "0x4000",
                  "ref_value": "0x2000"
            },
            "thread0.ag1_cr_efer": {
                  "description": "Architectural EFER MSR.",
                  "cr_offset": 16767,
                  "numbits": 32,
                  "desired_value": "0x800",
                  "ref_value": "0xd00"
            },
            "thread0.ag1_cr_efer_lma_lme": {
                  "description": "Architectural EFER MSR. LMA LME partial write",
                  "cr_offset": 16742,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag1_cr_apicbase": {
                  "description": "Register used to implement the APICBASE MSR. Contains the base address for all the APIC registers along with certain APIC control and state bits.",
                  "cr_offset": 315,
                  "numbits": 64,
                  "desired_value": "0xfee00800",
                  "ref_value": "0xfee00d00"
            },
            "thread0.ag1_cr_dr0": {
                  "description": "Architectural DR0 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 296,
                  "numbits": 64,
                  "desired_value": "0xaced",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.ag1_cr_dr1": {
                  "description": "Architectural DR1 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 297,
                  "numbits": 64,
                  "desired_value": "0x8000000000000000",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.ag1_cr_dr2": {
                  "description": "Architectural DR2 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 298,
                  "numbits": 64,
                  "desired_value": "0x800000000000010d",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.ag1_cr_dr3": {
                  "description": "Architectural DR3 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 299,
                  "numbits": 64,
                  "desired_value": "0x800000000000ca82",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.ag1_cr_dr7": {
                  "description": "Architectural DR7 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 376,
                  "numbits": 64,
                  "desired_value": "0x400",
                  "ref_value": "0x400"
            },
            "thread0.agu_cr_fault_reg1": {
                  "description": "Register containing event and access type information used by page and breakpoint event micro-code handlers. The lower 5 bits represent the page fault error code to be pushed when a page fault is detected.",
                  "cr_offset": 1302,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x1010003"
            },
            "thread0.agu_cr_fault_reg2": {
                  "description": "Register containing event and access type information used by page and breakpoint event micro-code handlers. The lower 5 bits represent the page fault error code to be pushed when a page fault is detected.",
                  "cr_offset": 1303,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x1020000000000048"
            },
            "thread0.pmh_cr_pkru": {
                  "description": "Holds 16 pairs of AD and WD using protection key rights checks for user",
                  "cr_offset": 1304,
                  "numbits": 32,
                  "desired_value": "0xfff3fcfc",
                  "ref_value": "0x0"
            },
            "thread0.dcu_cr_fault_reg0": {
                  "description": "Register containing the linear address for the access which caused a paging event.",
                  "cr_offset": 1306,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x7efaecc0"
            },
            "thread0.dtlb_cr_eptfault": {
                  "description": "EPT Fault Register - Fault Information",
                  "cr_offset": 1307,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_apic_access_page": {
                  "description": "Supports APIC virtualization. This register contains the physical address to be intercepted as accesses to the virtual APIC. The PMH compares this registers address to the final PA. Then depending on settings a shadow PA will be returned to the TLBs or the accesse will fault.",
                  "cr_offset": 1310,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_vtpr_page": {
                  "description": "Supports APIC virtualization. This register contains the physical address to use as the shadow TPR address.",
                  "cr_offset": 1315,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmh_cr_gpa_address": {
                  "description": "Guest  Physical Address - contains the GPA that caused the EPT fault. It should only be modified on EPT faults (although ucode won't use it in other places).",
                  "cr_offset": 1329,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmh_cr_gpa_ttrans": {
                  "description": "Guest Physical Address of the Final EPT Walk by a Tickle_Tran uop",
                  "cr_offset": 1330,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmh_cr_phys_uop_pa_pfx": {
                  "description": "Prefix of uTLB PA Translation",
                  "cr_offset": 1331,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmh_cr_pa_pfx_faultinfo": {
                  "description": "Prefix of faulting PA ",
                  "cr_offset": 1332,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmh_cr_ppa_amrr": {
                  "description": "  the access that causes the AMRR assist (assuming PMH walk resulted in the",
                  "cr_offset": 1334,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x7efae000"
            },
            "thread0.pmh_cr_ppa_and_attributes": {
                  "description": "Platform Physical Address from load/store_tickle_translate*",
                  "cr_offset": 1335,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmh_cr_remap": {
                  "description": "This register contains the address that should be used on an AMRR hit when REMAP_VALID creg bit is set in SLM_CR_PRF. Used for Probeless Debug Mode and internal debug. See Silvermont xT HAS AMRR doc.",
                  "cr_offset": 1339,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.slm_cr_prf": {
                  "description": "  works, how AMRR hits are detected, and how PMH walks that match AMRR load",
                  "cr_offset": 1348,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.x86_cr_cr3": {
                  "description": "Architectural CR3",
                  "cr_offset": 1349,
                  "numbits": 64,
                  "desired_value": "0x29d63000",
                  "ref_value": "0x76401000"
            },
            "thread0.mec_cr_shadow_prf": {
                  "description": "This creg gets a copy of the MEC_CR_PRF when the MEC assists for shadow stack uop ",
                  "cr_offset": 1351,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.mec_cr_hlatp": {
                  "description": "HLATP - HLAT Pointer (and control bits)",
                  "cr_offset": 1355,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pmh_cr_shared_eptp": {
                  "description": "Shared_EPTP.PML4_ADDR used in Shared access of SEAM mode",
                  "cr_offset": 1356,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.slm_cr_asid": {
                  "description": "Global address for the control registers which contain the Application Specific IDentifier of the currently executing process (ASID). Micro-code must update this register any time the ASID changes.",
                  "cr_offset": 1949,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.x86_cr_cr0": {
                  "description": "operating mode and states of the processor. The bits will be set to their correct architectural value by reset uCode",
                  "cr_offset": 2042,
                  "numbits": 32,
                  "desired_value": "0x31",
                  "ref_value": "0x80010013"
            },
            "thread0.x86_cr_cr4": {
                  "description": "Architectural CR4",
                  "cr_offset": 2046,
                  "numbits": 64,
                  "desired_value": "0x52e20",
                  "ref_value": "0x668"
            },
            "thread0.grt_cr_seam_mode": {
                  "description": "Mode bit for SEAM mode",
                  "cr_offset": 2012,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag2_cr_pppe": {
                  "description": "PPPE State bits",
                  "cr_offset": 17734,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag2_cr_vmx_clr": {
                  "description": "Clear VMX register",
                  "cr_offset": 1311,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag2_cr_se": {
                  "description": "SE State bits",
                  "cr_offset": 1361,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag2_cr_asid": {
                  "description": "Global address for the control registers which contain the Application Specific IDentifier of the currently executing process (ASID). Micro-code must update this register any time the ASID changes.",
                  "cr_offset": 1309,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ag2_cr_cr0": {
                  "description": "operating mode and states of the processor. The bits will be set to their correct architectural value by reset uCode",
                  "cr_offset": 1402,
                  "numbits": 32,
                  "desired_value": "0x31",
                  "ref_value": "0x80010013"
            },
            "thread0.ag2_cr_cr4": {
                  "description": "Architectural CR4",
                  "cr_offset": 1406,
                  "numbits": 64,
                  "desired_value": "0x52e20",
                  "ref_value": "0x668"
            },
            "thread0.ag2_cr_seam_mode": {
                  "description": "Mode bit for SEAM mode",
                  "cr_offset": 1372,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_call_depth": {
                  "description": "This creg contains the RTIT Call Depth",
                  "cr_offset": 132,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_cyc_count": {
                  "description": "This is the RTIT count register that contains a 19b counter that increments at a rate of core clock",
                  "cr_offset": 133,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_last_lip": {
                  "description": "The last LIP sent out as a packet payload.  Updated by HW on generation of any FUP or TIP* that includes a non-zero payload.  PacketEn=1 is required. LIP compression cases need only 32 bits.",
                  "cr_offset": 134,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_tnt_buff": {
                  "description": "This holds the (T)aken (N)ot-(T)aken indication for direct conditional branches or compressed return.",
                  "cr_offset": 135,
                  "numbits": 32,
                  "desired_value": "0x1",
                  "ref_value": "0x1"
            },
            "thread0.arr_cr_rtit_ucode_ctl_dis": {
                  "description": "The RTIT Microcode Control Enable register is a microcode only accessible register used to inhibit tracing when required.  This register can be read and written by microcode directly.  For performance reasons, this register can also be written using the SET/RESET indirection versions of this register",
                  "cr_offset": 136,
                  "numbits": 32,
                  "desired_value": "0x180000",
                  "ref_value": "0x180001"
            },
            "thread0.arr_cr_rtit_ucode_ctl_dis_reset": {
                  "description": "The RTIT Microcode Control Enable Reset register is a microcode only accessible register used to inhibit tracing when required.  Microcode uses the reset register for increased performance in resetting the enable bits as opposed to a read-modify-write operation.  The bit position written in the RTIT Microcode Control Enable Reset register will in turn reset the corresponding bit in the RTIT Microcode Control Enable register",
                  "cr_offset": 181,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_ucode_ctl_dis_set": {
                  "description": "The RTIT Microcode Control Enable Set register is a microcode only accessible register used to inhibit tracing when required.  Microcode uses the set register for increased performance in setting its enable bits as opposed to a read-modify-write operation",
                  "cr_offset": 180,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_ucode_drain": {
                  "description": "Used by micro-code to initiate RTIT buffer drain",
                  "cr_offset": 137,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_u_cet": {
                  "description": "Linear address of the user mode top of shadow stack pointer to be loaded into SSP on next supervisor to user mode transition. Must be machine canonical and the address must be aligned to 4 bytes i.e. bits 1:0 are reserved",
                  "cr_offset": 16620,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_s_cet": {
                  "description": "Linear address of the user mode top of shadow stack pointer to be loaded into SSP on next user to supervisor mode transition. Must be machine canonical and the address must be aligned to 4 bytes i.e. bits 1:0 are reserved",
                  "cr_offset": 16621,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rtit_ctl": {
                  "description": "This is the RTIT Control Register used to control RTIT features",
                  "cr_offset": 240,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_scp32_2": {
                  "description": "32 flops that can be set or cleared by write_jedata_rob with BRTYPE SCP32_2_SET or CLEAR",
                  "cr_offset": 1,
                  "numbits": 32,
                  "desired_value": "0x402",
                  "ref_value": "0x2a"
            },
            "thread0.arr_cr_assist_uip": {
                  "description": "UIP of the last uop that took a fault/assist. The difference from the RECOVERY_UIP creg on SLT is that this register will ONLY be updated on faults/assists. So the update of this creg and the ARR_CR_RETIRE_UIP creg is mutually exclusive. This register is only updated on MS uops i.e if the uipv signal in the allocate array (coped from the IQ auop) is set. It is zeroed out on BOPs. Due to overloading of uip field, the assist uip may not hold the correct uip value for branches that can jeclear, for FP BOM(zeroed out) and write_jedata_rob_imm cases. Overloading bug details are in GRT HSD 1707122412.",
                  "cr_offset": 2,
                  "numbits": 32,
                  "desired_value": "0xffff",
                  "ref_value": "0xffff"
            },
            "thread0.arr_cr_event_ctls": {
                  "description": "Register that provides control to a number of ROB event blocking mechanisms and state machines. In most cases, the bits in this register are only active when set. As a result, the commands are orthogonal and no read-modify-write is required when writing it. Assists and inserted flows that do not cause a transfer to a macrocode handler must not write this register. This register is used by micro-code and the ROB, and should not be generally used in debug. NOTE:this will be saved and restored for C6 via the creg loop and then the SS-SM and STI-SM will be reset later.",
                  "cr_offset": 24,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x400"
            },
            "thread0.arr_cr_event_ctls_reset": {
                  "description": "This is a microcode accessible only register for increased performance in clearing bits of ARR_CR_EVENT_CTLS instead of doign a RMW",
                  "cr_offset": 32,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_event_ctls_set": {
                  "description": "This is a microcode accessible only register for increased performance in setting bits of ARR_CR_EVENT_CTLS instead of doign a RMW",
                  "cr_offset": 33,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_event_inhibits": {
                  "description": "Each bit in this register corresponds to an event and when the bit is set the event is inhibited and when the bit is reset the event is allowed to be taken when it occurs.",
                  "cr_offset": 34,
                  "numbits": 32,
                  "desired_value": "0x702084",
                  "ref_value": "0x1ffffff"
            },
            "thread0.arr_cr_event_pending_reset": {
                  "description": "This control register is maintained by the exception control logic. It is a storage area where all the pending events are stored. Exception control logic uses this control register to signal pending events. When microcode wants to set and reset the bits in this control register it write to ARR_CR_EVENT_PENDING_SET_AND_STATUS and ARR_CR_EVENT_PENDING_RESET control registers respectively",
                  "cr_offset": 35,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_event_pending_set_and_status": {
                  "description": "This control register is maintained by the exception control logic. It is a storage area where all the pending events are stored. Exception control logic uses this control register to signal pending events. When microcode wants to set and reset the bits in this control register it write to ARR_CR_EVENT_PENDING_SET_AND_STATUS and ARR_CR_EVENT_PENDING_RESET control registers respectively",
                  "cr_offset": 112,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_faultinfo": {
                  "description": "Register used to enable various documented and undocumented debug features. See PPro Developer-s Manual, Vol. 3 for more information on the public features.",
                  "cr_offset": 36,
                  "numbits": 64,
                  "desired_value": "0x12411e08045400",
                  "ref_value": "0x12411e08045400"
            },
            "thread0.arr_cr_fip": {
                  "description": "CLIP for ucode for last floating point instruction",
                  "cr_offset": 10,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_fopcode": {
                  "description": "Register used to store the architectural FOPCODE value. The FOPCODE is the least significant 11 bits of the last 16-bit floating-point macroinstruction.",
                  "cr_offset": 37,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_fpc_event_info_4_mar": {
                  "description": "\"Register used to store event info for the FP and SSE exception handlers.  Written by the FPC when an FP or SSE uop events and used by ucode in the exception handlers.  Contains data useful to speed up loadop handling. The positions of all fields MUST match that in the mar struct\"",
                  "cr_offset": 38,
                  "numbits": 64,
                  "desired_value": "0x800001002100",
                  "ref_value": "0xc3100"
            },
            "thread0.arr_cr_lbr_tos": {
                  "description": "\"Contains a 5-bit pointer (0 ... 31) to the MSR in the LBR stack that contains the most recent branch, interrupt, or exception recorded.  Prior to placing a new branch record on the stack, the TOS is incremented by 1. When the TOS pointer reaches 31, it wraps around to 0.  LBR_TOS is zeroed out whenever we have a creg write to LBR_DEPTH\"",
                  "cr_offset": 9,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_clip": {
                  "description": "FROM address for the current LBR entry indexed by LBR_INDEX",
                  "cr_offset": 41,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_blip": {
                  "description": "TO address for the current LBR entry indexed by LBR_INDEX",
                  "cr_offset": 42,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_debug_clip": {
                  "description": "FROM address for the current LBR entry indexed by LBR_DEBUG_INDEX",
                  "cr_offset": 43,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_debug_blip": {
                  "description": "TO address for the current LBR entry indexed by LBR_DEBUG_INDEX",
                  "cr_offset": 44,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_ler_clip": {
                  "description": "Source address of the last branch taken prior to an exception or interrupt being generated. The address saved is the offset in the code segment of the branch source instruction",
                  "cr_offset": 45,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_ler_blip": {
                  "description": "Destination address of the last branch taken prior to an exception or interrupt being generated. The address saved is the offset in the code segment of the branch source instruction",
                  "cr_offset": 46,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_info": {
                  "description": "LBR info for the current LBR entry indexed by LBR_INDEX. This creg is physically same as LBR_INFO_DECREMENT_INDEX. But when read or written, it does NOT decrements LBR_INDEX",
                  "cr_offset": 48,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_info_decrement_index": {
                  "description": "LBR info for the current LBR entry indexed by LBR_INDEX. This creg is physically same as LBR_INFO. But when read or written, it also decrements LBR_INDEX",
                  "cr_offset": 49,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_debug_info_decrement_index": {
                  "description": "LBR info for the current LBR entry indexed by LBR_DEBUG_INDEX. When read or written, it also decrements LBR_DEBUG_INDEX",
                  "cr_offset": 50,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_ler_info": {
                  "description": "LBR info of the last branch taken prior to an exception or interrupt being generated. The address saved is the offset in the code segment of the branch source instruction",
                  "cr_offset": 51,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_lbr_index": {
                  "description": "\"Contains a 5-bit pointer (0 ... 31) to the MSR in the LBR stack that contains TO and FROM LIP. The index is updated by ucode prior to accessing the LBR for read or write.  LBR_INDEX is zeroed out whenever we have a creg write to LBR_DEPTH\"",
                  "cr_offset": 52,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x1b"
            },
            "thread0.arr_cr_lbr_debug_index": {
                  "description": "\"Contains a 5-bit pointer (0 ... 31) to the MSR in the LBR stack that contains TO and FROM LIP. The index is updated by ucode prior to accessing the LBR for read or write.  This is similar to LBR_INDEX, but for DEBUG use only\"",
                  "cr_offset": 53,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_nuke_action": {
                  "description": "This creg contains info for specifying how nuke action works. Nuke action must be a break event",
                  "cr_offset": 54,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_recovery_ipdelta": {
                  "description": "IPDELTA for corresponding RET NLIP for ucode",
                  "cr_offset": 56,
                  "numbits": 32,
                  "desired_value": "0x1",
                  "ref_value": "0x1"
            },
            "thread0.arr_cr_recovery_clip": {
                  "description": "TLIP for ucode recorded on last retired EOM.  Writes to RECOVERY_CLIP clear the ARR's internal bom_seen indication and ipdelta_at_bom as well as RECOVERY_IPDELTA",
                  "cr_offset": 57,
                  "numbits": 64,
                  "desired_value": "0xa267",
                  "ref_value": "0x746784d1"
            },
            "thread0.arr_cr_prev_recovery_clip": {
                  "description": "Previous RECOVERY_CLIP used by BTS",
                  "cr_offset": 58,
                  "numbits": 64,
                  "desired_value": "0x25042a01a05d",
                  "ref_value": "0x746784d1"
            },
            "thread0.arr_cr_recovery_tlip": {
                  "description": "TLIP is a virtual read-only register pointing to either the NLIP or CLIP based on whether a BOM has been seen.",
                  "cr_offset": 59,
                  "numbits": 64,
                  "desired_value": "0xa267",
                  "ref_value": "0x746784d1"
            },
            "thread0.arr_cr_retire_uip": {
                  "description": "UIP of the last retired MS uop. The difference from the RECOVERY_UIP creg on SLT is that this regster will NOT be updated on faults/assists. In other words, it is only updated on actual retirement of uops, so for example on a trap, it will have the uip of the last uop that retired. This register is only updated on MS uops i.e if the uipv signal in the allocate array (coped from the IQ auop) is set. Othwerise it retains the previous value. Due to overloading of uip field, the retire uip may not hold the correct uip value for branches that can jeclear, for FP BOM and write_jedata_rob_imm cases. Overloading bug details are in GRT HSD 1707122412",
                  "cr_offset": 60,
                  "numbits": 32,
                  "desired_value": "0x66c5",
                  "ref_value": "0x66c5"
            },
            "thread0.arr_cr_ret_status": {
                  "description": "Retirement Status register",
                  "cr_offset": 62,
                  "numbits": 32,
                  "desired_value": "0x17f8401",
                  "ref_value": "0x530007"
            },
            "thread0.arr_cr_tagword": {
                  "description": "Register used to store the architectural FTW. When read, the RAT's eight floating-point stack valid bits are returned in the least significant 8 bits of the register, with all other bits being 0. Note that these bits refer to the non-TOS relative stack registers, not to ST0-ST7 as referenced architecturally. The architectural FTW must be created from these valid bits. When written, the lower 16 bits of the data value are used as shown below to set the RAT-s eight floating-point stack valid bits. The upper 16 bits of write data are ignored. The RAT requires that any microinstruction in the machine between the time a write to this register executes and the time it retires not have either of the sources or the destination reference the floating-point stack (i.e. ST0 - ST7);",
                  "cr_offset": 16447,
                  "numbits": 32,
                  "desired_value": "0xff",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_tagword_direct8": {
                  "description": "\"Register used to simplify the FXRSTOR micro-code flow. When this register is accessed, the tag word will be written using a simpler, \"\"direct 8\"\" format for CRDataS35H. The 8 tags bits will be written directly to CRDataS35H[7:0] instead of using CRDataS35H[15:0].\"",
                  "cr_offset": 16448,
                  "numbits": 32,
                  "desired_value": "0xff",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_timout": {
                  "description": "ROB Timeout counter. sm:It is not MSR no more",
                  "cr_offset": 65,
                  "numbits": 32,
                  "desired_value": "0x8000",
                  "ref_value": "0x8000"
            },
            "thread0.arr_cr_unwind": {
                  "description": "unwind creg.",
                  "cr_offset": 0,
                  "numbits": 32,
                  "desired_value": "0x14",
                  "ref_value": "0x19"
            },
            "thread0.arr_cr_vmctl": {
                  "description": "fill description here",
                  "cr_offset": 29,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_x87_tos": {
                  "description": "C6 need to restore this creg",
                  "cr_offset": 16452,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_rob_livelock": {
                  "description": "Counter to detect exec (IEC/FPC) and MEC livelock condition",
                  "cr_offset": 70,
                  "numbits": 32,
                  "desired_value": "0x11",
                  "ref_value": "0x11"
            },
            "thread0.arr_cr_cet_ib_status": {
                  "description": "This control register is an alias control register. Each bit here is an alias for the corresponding bit in the ARR_CR_U_CET if the CPL is 3 else it aliases to ARR     _CR_S_CET",
                  "cr_offset": 16463,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_cet_virtual": {
                  "description": "This control register is an alias control register. Each bit here is an alias for the corresponding bit in the ARR_CR_U_CET if the CPL is 3 else it aliases to ARR_CR_S_CET",
                  "cr_offset": 16464,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_xstate_trk_reset": {
                  "description": "This control register is used to reset the init trackers",
                  "cr_offset": 4,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_xstate_trk_set_and_status": {
                  "description": "This control register is used for init tracking of various stat elements",
                  "cr_offset": 5,
                  "numbits": 32,
                  "desired_value": "0xf0003efb",
                  "ref_value": "0x30003cfb"
            },
            "thread0.arr_cr_recov_err": {
                  "description": "Parity Recovery Error Creg ",
                  "cr_offset": 91,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_unrecov_err": {
                  "description": "Parity Unrecovery Error Creg ",
                  "cr_offset": 92,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr_cr_scmisr_result_0": {
                  "description": "SCMISR_RESULT is a virtual creg (no physical flops) that reflects the value of the SCMISR result signal received from the SCMISR module in the arhfnunit fub",
                  "cr_offset": 104,
                  "numbits": 32,
                  "desired_value": "0x29",
                  "ref_value": "0x19"
            },
            "thread0.bnl_cr_sys_flags": {
                  "description": "       bit 0-7 and bit 11 zero out in BNL. cr_sys_flags_mnnnh[10:8] was removed        from the RTL signal path for c6 state checker purposes ... it is still",
                  "cr_offset": 18422,
                  "numbits": 32,
                  "desired_value": "0x2",
                  "ref_value": "0x202"
            },
            "thread0.global_cr_flat_cs": {
                  "description": "GLOBAL_CR_FLAT_CS",
                  "cr_offset": 18429,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_sys_flags": {
                  "description": "       bit 0-7 and bit 11 zero out in BNL. cr_sys_flags_mnnnh[10:8] was removed        from the RTL signal path for c6 state checker purposes ... it is still",
                  "cr_offset": 16502,
                  "numbits": 32,
                  "desired_value": "0x2",
                  "ref_value": "0x202"
            },
            "thread0.arr1_cr_flat_cs": {
                  "description": "ARR1_CR_FLAT_CS",
                  "cr_offset": 16509,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_lbr_ctl": {
                  "description": "Last Branch Record enabling and configuration register ",
                  "cr_offset": 16445,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_debugctlmsr": {
                  "description": "Register used to enable various documented and undocumented debug features. See PPro Developer-s Manual, Vol. 3 for more information on the public features. .",
                  "cr_offset": 16507,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_fixed_ctr0": {
                  "description": "Fixed PerfMon counter 0 - Instructions retired.",
                  "cr_offset": 97,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perf_global_ctrl": {
                  "description": "Global Perfmon Enable/Disable register",
                  "cr_offset": 47,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perf_global_ctrl_preserve_alias": {
                  "description": "GRT 1408258877: This is identical to PERF_GLOBAL_CTRL, and reads/writes the same state. The only difference is documented below in ENABLE_GP_PERFMON_COUNTER_7",
                  "cr_offset": 15,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel0": {
                  "description": "perf event selector for general counter 0",
                  "cr_offset": 71,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel1": {
                  "description": "perf event selector for general counter 1",
                  "cr_offset": 72,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel2": {
                  "description": "perf event selector for general counter 2",
                  "cr_offset": 73,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel3": {
                  "description": "perf event selector for general counter 3",
                  "cr_offset": 74,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel4": {
                  "description": "perf event selector for general counter 4",
                  "cr_offset": 75,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel5": {
                  "description": "perf event selector for general counter 5",
                  "cr_offset": 76,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel6": {
                  "description": "perf event selector for general counter 6",
                  "cr_offset": 77,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel7": {
                  "description": "perf event selector for general counter 7",
                  "cr_offset": 78,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel0_ext": {
                  "description": "Extended Perf event selctor for GP counter 0",
                  "cr_offset": 82,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel1_ext": {
                  "description": "Extended Perf event selctor for GP counter 1",
                  "cr_offset": 83,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel2_ext": {
                  "description": "Extended Perf event selctor for GP counter 2",
                  "cr_offset": 84,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel3_ext": {
                  "description": "Extended Perf event selctor for GP counter 3",
                  "cr_offset": 85,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel4_ext": {
                  "description": "Extended Perf event selctor for GP counter 4",
                  "cr_offset": 86,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel5_ext": {
                  "description": "Extended Perf event selctor for GP counter 5",
                  "cr_offset": 87,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel6_ext": {
                  "description": "Extended Perf event selctor for GP counter 6",
                  "cr_offset": 88,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_perfevtsel7_ext": {
                  "description": "Extended Perf event selctor for GP counter 7",
                  "cr_offset": 89,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_pmc0": {
                  "description": "General purpose counter 0. This was changed to a global creg on GLM for the sake of PEBS PDIR. BUS1 needs to also support reads of the local address (BUS1_CR_PMC0) for the sake of the RDPMC macro instruction.",
                  "cr_offset": 96,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_pmc1": {
                  "description": "General purpose counter 1. This was changed to a global creg on GLM for the sake of PEBS PDIR. BUS1 needs to also support reads of the local address (BUS1_CR_PMC1) for the sake of the RDPMC macro instruction.",
                  "cr_offset": 100,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_fixed_ctr_ctrl": {
                  "description": "Global Perfmon Overflow clear register. BIU HW will clear the corresponding overflow in 38:32 of PERF_GLOBAL_STATUS if there is any change in value of bits 27:0 (Each 4 bit field affects its corresponding overflow).",
                  "cr_offset": 13,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_fixed_ctr0_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 0",
                  "cr_offset": 21,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_fixed_ctr1_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 1",
                  "cr_offset": 22,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_fixed_ctr2_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 2",
                  "cr_offset": 23,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_fixed_ctr4_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 4",
                  "cr_offset": 25,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_fixed_ctr5_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 5",
                  "cr_offset": 26,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_fixed_ctr6_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 6",
                  "cr_offset": 27,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_probe_mode_status": {
                  "description": "fill description here",
                  "cr_offset": 98,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_fp_status_word": {
                  "description": "Moved to a global CR on GLP so that the ES pending bit usage in ARR can be moved up 2 cycles to fix GLP HSDES 1403962535",
                  "cr_offset": 12,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_cpl": {
                  "description": "        which contain the privilege level of the currently executing process    (CPL). Micro-code must update this register any time the privilege",
                  "cr_offset": 30,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_vmx_clr": {
                  "description": "Clear VMX register",
                  "cr_offset": 31,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_cs_l_d_bits": {
                  "description": "        which contain the CS L and D bit. uCode usee this creg to       broadcast L and D bit.",
                  "cr_offset": 16501,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_efer": {
                  "description": "Architectural EFER MSR.",
                  "cr_offset": 16511,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_efer_lma_lme": {
                  "description": "Architectural EFER MSR. LMA LME partial write",
                  "cr_offset": 16486,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_dr7": {
                  "description": "Architectural DR7 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 120,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_se": {
                  "description": "SE State bits",
                  "cr_offset": 81,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.arr1_cr_cr0": {
                  "description": "operating mode and states of the processor. The bits will be set to their correct architectural value by reset uCode",
                  "cr_offset": 122,
                  "numbits": 32,
                  "desired_value": "0x1",
                  "ref_value": "0x80000001"
            },
            "thread0.arr1_cr_cr4": {
                  "description": "Architectural CR4",
                  "cr_offset": 126,
                  "numbits": 64,
                  "desired_value": "0x20",
                  "ref_value": "0x20"
            },
            "thread0.bnl_cr_ss_b_bit": {
                  "description": "SS B-bit",
                  "cr_offset": 1852,
                  "numbits": 32,
                  "desired_value": "0x4000",
                  "ref_value": "0x4000"
            },
            "thread0.bp_cr_recirc_clip": {
                  "description": "fill description here",
                  "cr_offset": 1794,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_recirc_ipdelta": {
                  "description": "fill description here",
                  "cr_offset": 1820,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.id_cr_debug_defeature": {
                  "description": "  despite this creg name, many of these bits may be used for normal",
                  "cr_offset": 1793,
                  "numbits": 64,
                  "desired_value": "0x19c4080000000180",
                  "ref_value": "0x39c0080000000181"
            },
            "thread0.id_cr_mar0": {
                  "description": "Macro Alias Register. Bit positions defined in bnl_structs",
                  "cr_offset": 1874,
                  "numbits": 64,
                  "desired_value": "0x36042963320c",
                  "ref_value": "0x36043023330c"
            },
            "thread0.id_cr_vmx_pppe_mar": {
                  "description": "Alias to read/write the MAR for VMX/PPPE. The format/encodings are to match Core uarch / VMX/PPPE spec",
                  "cr_offset": 1797,
                  "numbits": 32,
                  "desired_value": "0x51c18c98",
                  "ref_value": "0x1c18d18"
            },
            "thread0.bp_cr_flat_cs": {
                  "description": "BP_CR_FLAT_CS",
                  "cr_offset": 18301,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_perfevtsel0": {
                  "description": "perf event selector for general counter 0",
                  "cr_offset": 1863,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_perfevtsel1": {
                  "description": "perf event selector for general counter 1",
                  "cr_offset": 1864,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_perfevtsel2": {
                  "description": "perf event selector for general counter 2",
                  "cr_offset": 1865,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_perfevtsel3": {
                  "description": "perf event selector for general counter 3",
                  "cr_offset": 1866,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_perfevtsel4": {
                  "description": "perf event selector for general counter 4",
                  "cr_offset": 1867,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_perfevtsel5": {
                  "description": "perf event selector for general counter 5",
                  "cr_offset": 1868,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_perfevtsel6": {
                  "description": "perf event selector for general counter 6",
                  "cr_offset": 1869,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_perfevtsel7": {
                  "description": "perf event selector for general counter 7",
                  "cr_offset": 1870,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_cs_base": {
                  "description": "Global address for the control registers which contain the base address of the currently executing process. . For Probe Mode, this MSR is write only; read value is irrelevant",
                  "cr_offset": 18190,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_cs_l_d_bits": {
                  "description": "        which contain the CS L and D bit. uCode usee this creg to       broadcast L and D bit.",
                  "cr_offset": 18293,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_efer": {
                  "description": "Architectural EFER MSR.",
                  "cr_offset": 18303,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_efer_lma_lme": {
                  "description": "Architectural EFER MSR. LMA LME partial write",
                  "cr_offset": 18278,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_cr0": {
                  "description": "operating mode and states of the processor. The bits will be set to their correct architectural value by reset uCode",
                  "cr_offset": 1914,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bp_cr_cr4": {
                  "description": "Architectural CR4",
                  "cr_offset": 1918,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_dummy_creg": {
                  "description": "Dummy register to match BUS CREG timing for Ucode to use. DKTFIXME - Check with ucode if this needs to be RW with backing Flops",
                  "cr_offset": 8704,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_perf_global_ctrl_preserve_alias": {
                  "description": "GRT 1408258877: This is identical to PERF_GLOBAL_CTRL, and reads/writes the same state. The only difference is documented below in ENABLE_GP_PERFMON_COUNTER_7",
                  "cr_offset": 10127,
                  "numbits": 64,
                  "desired_value": "0xff",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_lbr_ctl": {
                  "description": "Last Branch Record enabling and configuration register ",
                  "cr_offset": 25149,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_debugctlmsr": {
                  "description": "Register used to enable various documented and undocumented debug features. See PPro Developer-s Manual, Vol. 3 for more information on the public features. .",
                  "cr_offset": 25211,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_fixed_ctr0": {
                  "description": "Fixed PerfMon counter 0 - Instructions retired.",
                  "cr_offset": 8801,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perf_global_ctrl": {
                  "description": "Global Perfmon Enable/Disable register",
                  "cr_offset": 8751,
                  "numbits": 64,
                  "desired_value": "0xff",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perf_global_ctrl_preserve_alias": {
                  "description": "GRT 1408258877: This is identical to PERF_GLOBAL_CTRL, and reads/writes the same state. The only difference is documented below in ENABLE_GP_PERFMON_COUNTER_7",
                  "cr_offset": 8719,
                  "numbits": 64,
                  "desired_value": "0xff",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel0": {
                  "description": "perf event selector for general counter 0",
                  "cr_offset": 8775,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel1": {
                  "description": "perf event selector for general counter 1",
                  "cr_offset": 8776,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel2": {
                  "description": "perf event selector for general counter 2",
                  "cr_offset": 8777,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel3": {
                  "description": "perf event selector for general counter 3",
                  "cr_offset": 8778,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel4": {
                  "description": "perf event selector for general counter 4",
                  "cr_offset": 8779,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel5": {
                  "description": "perf event selector for general counter 5",
                  "cr_offset": 8780,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel6": {
                  "description": "perf event selector for general counter 6",
                  "cr_offset": 8781,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel7": {
                  "description": "perf event selector for general counter 7",
                  "cr_offset": 8782,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel0_ext": {
                  "description": "Extended Perf event selctor for GP counter 0",
                  "cr_offset": 8786,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel1_ext": {
                  "description": "Extended Perf event selctor for GP counter 1",
                  "cr_offset": 8787,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel2_ext": {
                  "description": "Extended Perf event selctor for GP counter 2",
                  "cr_offset": 8788,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel3_ext": {
                  "description": "Extended Perf event selctor for GP counter 3",
                  "cr_offset": 8789,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel4_ext": {
                  "description": "Extended Perf event selctor for GP counter 4",
                  "cr_offset": 8790,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel5_ext": {
                  "description": "Extended Perf event selctor for GP counter 5",
                  "cr_offset": 8791,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel6_ext": {
                  "description": "Extended Perf event selctor for GP counter 6",
                  "cr_offset": 8792,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_perfevtsel7_ext": {
                  "description": "Extended Perf event selctor for GP counter 7",
                  "cr_offset": 8793,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_pmc0": {
                  "description": "General purpose counter 0. This was changed to a global creg on GLM for the sake of PEBS PDIR. BUS1 needs to also support reads of the local address (BUS1_CR_PMC0) for the sake of the RDPMC macro instruction.",
                  "cr_offset": 8800,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_pmc1": {
                  "description": "General purpose counter 1. This was changed to a global creg on GLM for the sake of PEBS PDIR. BUS1 needs to also support reads of the local address (BUS1_CR_PMC1) for the sake of the RDPMC macro instruction.",
                  "cr_offset": 8804,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_fixed_ctr_ctrl": {
                  "description": "Global Perfmon Overflow clear register. BIU HW will clear the corresponding overflow in 38:32 of PERF_GLOBAL_STATUS if there is any change in value of bits 27:0 (Each 4 bit field affects its corresponding overflow).",
                  "cr_offset": 8717,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_fixed_ctr0_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 0",
                  "cr_offset": 8725,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_fixed_ctr1_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 1",
                  "cr_offset": 8726,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_fixed_ctr2_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 2",
                  "cr_offset": 8727,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_fixed_ctr4_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 4",
                  "cr_offset": 8729,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_fixed_ctr5_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 5",
                  "cr_offset": 8730,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_fixed_ctr6_ctrl_ext": {
                  "description": "Extended Perf event selctor for Fixed counter 6",
                  "cr_offset": 8731,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_cpl": {
                  "description": "        which contain the privilege level of the currently executing process    (CPL). Micro-code must update this register any time the privilege",
                  "cr_offset": 8734,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus1_cr_vmx_clr": {
                  "description": "Clear VMX register",
                  "cr_offset": 8735,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_inhibit": {
                  "description": "Please talk to Anthony, Sanjoy, or Jeff before making changes to this CREG",
                  "cr_offset": 8870,
                  "numbits": 32,
                  "desired_value": "0xe09",
                  "ref_value": "0x1ffff"
            },
            "thread0.bus_cr_pcpins": {
                  "description": "fill description here",
                  "cr_offset": 8871,
                  "numbits": 32,
                  "desired_value": "0x80000",
                  "ref_value": "0x1"
            },
            "thread0.bus_cr_pcpmg": {
                  "description": "fill description here",
                  "cr_offset": 8945,
                  "numbits": 32,
                  "desired_value": "0x200",
                  "ref_value": "0x200"
            },
            "thread0.bus_cr_pending_reset": {
                  "description": "fill description here",
                  "cr_offset": 8862,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_pending_set_and_status": {
                  "description": "fill description here",
                  "cr_offset": 8863,
                  "numbits": 32,
                  "desired_value": "0x2000",
                  "ref_value": "0x5"
            },
            "thread0.pic_cr_nmi_source": {
                  "description": "PIC NMI Source Register",
                  "cr_offset": 8872,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_nmi_source_set": {
                  "description": "PIC SET NMI Source Interface for Ucode",
                  "cr_offset": 8873,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_nmi_source_reset": {
                  "description": "PIC RESET NMI Source Interface for Ucode",
                  "cr_offset": 8874,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_pic_config_state_status": {
                  "description": "PIC Configuration Register",
                  "cr_offset": 8875,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_pic_piclet_state": {
                  "description": "Read-only register that returns APICIDs, LDR, DFR and enable bits in the layout that is consistent with Tunit.",
                  "cr_offset": 8880,
                  "numbits": 64,
                  "desired_value": "0x3000000180000000",
                  "ref_value": "0x3800000180000000"
            },
            "thread0.bus_cr_pic_thread_config": {
                  "description": "Legacy name is PIC_CR_COMMAND. Some bits from MRM's PIC_CR_STATUS are also defined in this creg.",
                  "cr_offset": 8900,
                  "numbits": 32,
                  "desired_value": "0x801400",
                  "ref_value": "0x801000"
            },
            "thread0.bus_cr_ucode_tscd": {
                  "description": "ucode deadline timer",
                  "cr_offset": 8881,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_pic_timer_status": {
                  "description": "PIC Timer status interface register",
                  "cr_offset": 8892,
                  "numbits": 32,
                  "desired_value": "0x10800",
                  "ref_value": "0x285705"
            },
            "thread0.bus_cr_pic_timer_status_set": {
                  "description": "PIC Timer status Set interface register",
                  "cr_offset": 8893,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_pic_timer_status_reset": {
                  "description": "PIC Timer status Reset interface register",
                  "cr_offset": 8896,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_pic_ttt": {
                  "description": "Timer Target Time",
                  "cr_offset": 8899,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0xbdc4f27914a"
            },
            "thread0.bus_cr_pic_uncore_trap_event_inhibit": {
                  "description": "Uncore Trap Event Inhibit Register",
                  "cr_offset": 8901,
                  "numbits": 32,
                  "desired_value": "0x8",
                  "ref_value": "0x8"
            },
            "thread0.bus_cr_pic_uncore_trap_event_reset": {
                  "description": "Uncore Trap Event Reset Register",
                  "cr_offset": 8902,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_pic_uncore_trap_event_set_and_status": {
                  "description": "Uncore Trap Event Set and Status Register",
                  "cr_offset": 8903,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ebl_cr_cmp_semaphore": {
                  "description": "contains the semaphores mechanism that will be used in micro-code to prevent non-synchronized accesses to shared resources in CMP.",
                  "cr_offset": 8841,
                  "numbits": 32,
                  "desired_value": "0xaa",
                  "ref_value": "0xaa"
            },
            "thread0.ebl_cr_lt_doorbell": {
                  "description": "This register returns the status of the LT doorbell bus events Each bit reflects the detection of an LT bus event corresponding to the LT private address space at 0xFED20Erx.  Where the hex digit of 'r' (bits 7:4) corresponds to a bit position in this register.",
                  "cr_offset": 8832,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0xe0000"
            },
            "thread0.ebl_cr_lt_doorbell_inhibit": {
                  "description": "This register provides inhibit control over LT bus event signaling to the micro-code.  Each bit controls the inhibit over the signaling of an LT bus event corresponding to the LT private address space at 0xFED20Erx.  Where the hex digit 'r' (bits 7:4) corresponds to a bit position in this register.",
                  "cr_offset": 8833,
                  "numbits": 32,
                  "desired_value": "0xfffeffff",
                  "ref_value": "0xfffefffe"
            },
            "thread0.ebl_cr_lt_doorbell_reset": {
                  "description": "This register does not exist. micro-code uses this address to reset the bit if we write a 1 and a write of 0 has no effect. This register provides reset control over LT bus event status as reflected in FSB_CR_PIC_LT_DOORBELL.  Each bit corresponds to the status bit at the same position.",
                  "cr_offset": 8904,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ebl_cr_lt_doorbell_set": {
                  "description": "This register does not exist. Micro-code uses this address to set the bit if we write a 1, and a write of 0 has no effect. This register provides set control over LT bus event status as reflected in EBL_CR_LT_DOORBELL.",
                  "cr_offset": 8905,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_core_tsc_deadline": {
                  "description": "Stores the time of the next APIC Timer interrupt using the TSC time domain.",
                  "cr_offset": 8906,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0xbdc4f27914a"
            },
            "thread0.pic_cr_apic_state": {
                  "description": "fill description here",
                  "cr_offset": 8890,
                  "numbits": 32,
                  "desired_value": "0x81ff",
                  "ref_value": "0xa10f"
            },
            "thread0.pic_cr_cross_core_communication_mycore": {
                  "description": "fill description here",
                  "cr_offset": 8909,
                  "numbits": 32,
                  "desired_value": "0x40",
                  "ref_value": "0x40"
            },
            "thread0.pic_cr_queue_status": {
                  "description": "fill description here",
                  "cr_offset": 8956,
                  "numbits": 64,
                  "desired_value": "0xf00000100",
                  "ref_value": "0xf00000418"
            },
            "thread0.pic_cr_debug_modes_c6": {
                  "description": "fill description here",
                  "cr_offset": 8844,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_local_apic_id": {
                  "description": "PIC Logical APIC ID register",
                  "cr_offset": 8889,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_irr01": {
                  "description": "APIC Interrupt Request register bits",
                  "cr_offset": 8856,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_isr01": {
                  "description": "APIC In-Service register bits",
                  "cr_offset": 8848,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_tmr01": {
                  "description": "APIC Trigger Mode register bits",
                  "cr_offset": 8852,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_irr23": {
                  "description": "APIC Interrupt Request register bits",
                  "cr_offset": 8857,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x1"
            },
            "thread0.pic_cr_pic_isr23": {
                  "description": "APIC In-Service register bits",
                  "cr_offset": 8849,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_tmr23": {
                  "description": "APIC Trigger Mode register bits",
                  "cr_offset": 8853,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_irr45": {
                  "description": "APIC Interrupt Request register bits",
                  "cr_offset": 8858,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_isr45": {
                  "description": "APIC In-Service register bits",
                  "cr_offset": 8850,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_tmr45": {
                  "description": "APIC Trigger Mode register bits",
                  "cr_offset": 8854,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_irr67": {
                  "description": "APIC Interrupt Request register bits",
                  "cr_offset": 8859,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_isr67": {
                  "description": "APIC In-Service register bits",
                  "cr_offset": 8851,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_pic_tmr67": {
                  "description": "APIC Trigger Mode register bits",
                  "cr_offset": 8855,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_sipi_vector": {
                  "description": "Holds the vector of the last SIPI interrupt for micro-code. Note: reading this CR clears pending SIPI indication in PCPINS - so it should never be read speculatively. In Bonnell, it is not probe mode MSR. It was in MEROM.  New for STW:this register is writable for STW i1063679 for SBFT; writing the register causes a SIPI to be pended with the vector written.",
                  "cr_offset": 8839,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_status": {
                  "description": "PIC status register. except CLEAR_APIC_STATE, which is a command bit. Mixed scope register:Only bits 2,3,4,5 are module scope",
                  "cr_offset": 8846,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_tpr": {
                  "description": "Aarchitectural CR8. An alias to the APIC's TPR register.",
                  "cr_offset": 8916,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_tpr_update": {
                  "description": "Force IntPriUp",
                  "cr_offset": 8865,
                  "numbits": 64,
                  "desired_value": "0x80",
                  "ref_value": "0x40c6"
            },
            "thread0.pic_cr_vmx_timer": {
                  "description": "Stores the VMX Timer Count.",
                  "cr_offset": 8951,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_vmx_timer_ctrl": {
                  "description": "Stores the VMX Timer Count.",
                  "cr_offset": 8952,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_vmx_timer_ctrl_reset": {
                  "description": "RESET the VMX Timer CTRL Bits.",
                  "cr_offset": 8918,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.pic_cr_vmx_timer_ctrl_set": {
                  "description": "SET the VMX Timer CTRL Bits.",
                  "cr_offset": 8919,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus2_cr_rtit_ctl": {
                  "description": "This is the RTIT Control Register used to control RTIT features",
                  "cr_offset": 8944,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus2_cr_apicbase": {
                  "description": "Register used to implement the APICBASE MSR. Contains the base address for all the APIC registers along with certain APIC control and state bits.",
                  "cr_offset": 8891,
                  "numbits": 64,
                  "desired_value": "0x800",
                  "ref_value": "0xc00"
            },
            "thread0.bus_cr_enh_mca_command": {
                  "description": " Command register that ucode can write to trigger different Enhanced MCA signals ",
                  "cr_offset": 9127,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bus_cr_ucode_pla_entry": {
                  "description": "Register to indicate what entry of the PLA wants to be read",
                  "cr_offset": 9186,
                  "numbits": 64,
                  "desired_value": "0x8000000000058000",
                  "ref_value": "0x80000020750f0041"
            },
            "thread0.bus_cr_ucode_pla_data_0": {
                  "description": "First register where the data that was read from the PLA is saved",
                  "cr_offset": 9187,
                  "numbits": 64,
                  "desired_value": "0x58000841040fed30",
                  "ref_value": "0xfc00ea6009dbc5fc"
            },
            "thread0.bus_cr_ucode_pla_data_1": {
                  "description": "Second register where the data that was read from the PLA is saved",
                  "cr_offset": 9188,
                  "numbits": 64,
                  "desired_value": "0xffffffe000f09",
                  "ref_value": "0x2000000024b"
            },
            "thread0.fpc_cr_event_info": {
                  "description": "\"Register used to store event info for the faulting FP, SSE, and AVX exception handlers.  Written by the FPC when an X87, SSE, or AVX low uop faults and used by ucode in the exception handlers.\"",
                  "cr_offset": 1152,
                  "numbits": 32,
                  "desired_value": "0x820",
                  "ref_value": "0x0"
            },
            "thread0.fpc_cr_event_info1": {
                  "description": "\"Register used to store event info for the AVX exception handler.  Only written by the FPC when the upper-half of an AVX256 uop faults and is used by ucode in the AVX exception handler.\"",
                  "cr_offset": 1153,
                  "numbits": 32,
                  "desired_value": "0x820",
                  "ref_value": "0x0"
            },
            "thread0.fpc_cr_fsw_fccpef_sidedoor": {
                  "description": "Fake creg interface to FSW that provides a sidedoor mechanism for ucode to modify C3, C2, C1, C0, and PEF in FP_STATUS_WORD with an additional mask payload which specifies which of those fields to modify and which to preserve",
                  "cr_offset": 1154,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.fpc_cr_event_mxcsr_avx_lo": {
                  "description": "\"Register used to store MXCSR flags for the non-faulting portion of the AVX (low) uop for the AVX exception handler.  Only written by the FPC when the upper-half of an AVX256 uop faultss and is used by ucode in the AVX exception handler.\"",
                  "cr_offset": 1155,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.fpc_cr_event_mxcsr_avx_hi": {
                  "description": "\"Register used to store MXCSR flags for the non-faulting portion of the AVX (high) uop for the AVX exception handler.  Only written by the FPC when the lower-half of an  AVX256 uop faults and is used by ucode in the AVX exception handler.\"",
                  "cr_offset": 1156,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.x86_cr_fp_status_word": {
                  "description": "Moved to a global CR on GLP so that the ES pending bit usage in ARR can be moved up 2 cycles to fix GLP HSDES 1403962535",
                  "cr_offset": 1932,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.fpc_cr_fp_status_word": {
                  "description": "Moved to a global CR on GLP so that the ES pending bit usage in ARR can be moved up 2 cycles to fix GLP HSDES 1403962535",
                  "cr_offset": 1164,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.global_cr_crosscluster_debug_defeature": {
                  "description": "debug defeature to disable cross cluster or unit feature from DKT",
                  "cr_offset": 1983,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bnl_cr_probe_mode_status": {
                  "description": "fill description here",
                  "cr_offset": 2018,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ic_cr_crosscluster_debug_defeature": {
                  "description": "debug defeature to disable cross cluster or unit feature from DKT",
                  "cr_offset": 1599,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ic_cr_probe_mode_status": {
                  "description": "fill description here",
                  "cr_offset": 1634,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ic_cr_pppe": {
                  "description": "PPPE State bits",
                  "cr_offset": 17990,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ic_cr_cpl": {
                  "description": "        which contain the privilege level of the currently executing process    (CPL). Micro-code must update this register any time the privilege",
                  "cr_offset": 1566,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ic_cr_vmx_clr": {
                  "description": "Clear VMX register",
                  "cr_offset": 1567,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ic_cr_dr0": {
                  "description": "Architectural DR0 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 1576,
                  "numbits": 64,
                  "desired_value": "0xaced",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.ic_cr_dr1": {
                  "description": "Architectural DR1 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 1577,
                  "numbits": 64,
                  "desired_value": "0x8000000000000000",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.ic_cr_dr2": {
                  "description": "Architectural DR2 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 1578,
                  "numbits": 64,
                  "desired_value": "0x800000000000010d",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.ic_cr_dr3": {
                  "description": "Architectural DR3 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 1579,
                  "numbits": 64,
                  "desired_value": "0x800000000000ca82",
                  "ref_value": "0x8000000000000000"
            },
            "thread0.ic_cr_dr7": {
                  "description": "Architectural DR7 - Refer to Software Developer's Manual vol. 3 chapter 15",
                  "cr_offset": 1656,
                  "numbits": 64,
                  "desired_value": "0x400",
                  "ref_value": "0x400"
            },
            "thread0.ic_cr_asid": {
                  "description": "Global address for the control registers which contain the Application Specific IDentifier of the currently executing process (ASID). Micro-code must update this register any time the ASID changes.",
                  "cr_offset": 1565,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ic_cr_cr0": {
                  "description": "operating mode and states of the processor. The bits will be set to their correct architectural value by reset uCode",
                  "cr_offset": 1658,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ic_cr_cr4": {
                  "description": "Architectural CR4",
                  "cr_offset": 1662,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.iec_cr_cs_limit": {
                  "description": "BAC copy of the current CS Limit .",
                  "cr_offset": 17424,
                  "numbits": 32,
                  "desired_value": "0xffffffff",
                  "ref_value": "0xffffffff"
            },
            "thread0.iec_cr_dummy_creg": {
                  "description": "fill description here",
                  "cr_offset": 1024,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.iec_cr_modes_and_defeatures": {
                  "description": "Contains thread specific defeature controls as well as controls for that ucode can use to set some specific modes.",
                  "cr_offset": 1026,
                  "numbits": 32,
                  "desired_value": "0x3",
                  "ref_value": "0x3"
            },
            "thread0.iec_cr_non_canonical_la_63_48": {
                  "description": "LA 63:48 for non-canonical fault (including converted to maskmov assist) detected by Agen",
                  "cr_offset": 1027,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bnl_cr_cs_base": {
                  "description": "Global address for the control registers which contain the base address of the currently executing process. . For Probe Mode, this MSR is write only; read value is irrelevant",
                  "cr_offset": 18318,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.iec_cr_sys_flags": {
                  "description": "       bit 0-7 and bit 11 zero out in BNL. cr_sys_flags_mnnnh[10:8] was removed        from the RTL signal path for c6 state checker purposes ... it is still",
                  "cr_offset": 17526,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.iec_cr_flat_cs": {
                  "description": "IEC_CR_FLAT_CS",
                  "cr_offset": 17533,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.iec_cr_pppe": {
                  "description": "PPPE State bits",
                  "cr_offset": 17478,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.iec_cr_cpl": {
                  "description": "        which contain the privilege level of the currently executing process    (CPL). Micro-code must update this register any time the privilege",
                  "cr_offset": 1054,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.iec_cr_cs_base": {
                  "description": "Global address for the control registers which contain the base address of the currently executing process. . For Probe Mode, this MSR is write only; read value is irrelevant",
                  "cr_offset": 17422,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.iec_cr_cs_l_d_bits": {
                  "description": "        which contain the CS L and D bit. uCode usee this creg to       broadcast L and D bit.",
                  "cr_offset": 17525,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x2000"
            },
            "thread0.iec_cr_efer": {
                  "description": "Architectural EFER MSR.",
                  "cr_offset": 17535,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x400"
            },
            "thread0.iec_cr_efer_lma_lme": {
                  "description": "Architectural EFER MSR. LMA LME partial write",
                  "cr_offset": 17510,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.iec_cr_cr0": {
                  "description": "operating mode and states of the processor. The bits will be set to their correct architectural value by reset uCode",
                  "cr_offset": 1146,
                  "numbits": 32,
                  "desired_value": "0x1",
                  "ref_value": "0x1"
            },
            "thread0.iec_cr_cr4": {
                  "description": "Architectural CR4",
                  "cr_offset": 1150,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms_cr_fast_branch_intra_flow": {
                  "description": "uCode controlled intra-flow fast branch state",
                  "cr_offset": 1733,
                  "numbits": 32,
                  "desired_value": "0x80b",
                  "ref_value": "0xb"
            },
            "thread0.ms_cr_fast_branch_ucode": {
                  "description": "uCode controlled fast branch state",
                  "cr_offset": 1731,
                  "numbits": 32,
                  "desired_value": "0x1819",
                  "ref_value": "0x1a1b"
            },
            "thread0.ms_cr_fast_branch_ucode_set": {
                  "description": "uCode controlled fast branch state",
                  "cr_offset": 1668,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms_cr_fast_branch_vmx": {
                  "description": "Only flexible VMX execution controls bits. Note that the format of this register is aligned with the formats of SCP_CR_VMX_EXECUTION_CONTROLS and SCP_CR_PPPE_VMX_EXECUTION_CONTROLS",
                  "cr_offset": 1728,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms_cr_ubrk": {
                  "description": "Micro Break Point Creg.",
                  "cr_offset": 1671,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.bnl_cr_pppe": {
                  "description": "PPPE State bits",
                  "cr_offset": 18374,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_u_cet": {
                  "description": "Linear address of the user mode top of shadow stack pointer to be loaded into SSP on next supervisor to user mode transition. Must be machine canonical and the address must be aligned to 4 bytes i.e. bits 1:0 are reserved",
                  "cr_offset": 18156,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_s_cet": {
                  "description": "Linear address of the user mode top of shadow stack pointer to be loaded into SSP on next user to supervisor mode transition. Must be machine canonical and the address must be aligned to 4 bytes i.e. bits 1:0 are reserved",
                  "cr_offset": 18157,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_sys_flags": {
                  "description": "       bit 0-7 and bit 11 zero out in BNL. cr_sys_flags_mnnnh[10:8] was removed        from the RTL signal path for c6 state checker purposes ... it is still",
                  "cr_offset": 18166,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_pppe": {
                  "description": "PPPE State bits",
                  "cr_offset": 18118,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_cpl": {
                  "description": "        which contain the privilege level of the currently executing process    (CPL). Micro-code must update this register any time the privilege",
                  "cr_offset": 1694,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_vmx_clr": {
                  "description": "Clear VMX register",
                  "cr_offset": 1695,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_cs_l_d_bits": {
                  "description": "        which contain the CS L and D bit. uCode usee this creg to       broadcast L and D bit.",
                  "cr_offset": 18165,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_efer": {
                  "description": "Architectural EFER MSR.",
                  "cr_offset": 18175,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_efer_lma_lme": {
                  "description": "Architectural EFER MSR. LMA LME partial write",
                  "cr_offset": 18150,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_se": {
                  "description": "SE State bits",
                  "cr_offset": 1745,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_cr0": {
                  "description": "operating mode and states of the processor. The bits will be set to their correct architectural value by reset uCode",
                  "cr_offset": 1786,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_cr4": {
                  "description": "Architectural CR4",
                  "cr_offset": 1790,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ms1_cr_seam_mode": {
                  "description": "Mode bit for SEAM mode",
                  "cr_offset": 1756,
                  "numbits": 32,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ucode_cr_probe_lt_spc_cyc": {
                  "description": "This is special creg for Probe Mode, used for issuing LT Special Cycles to the chipset in RED unlocked part",
                  "cr_offset": 8987,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ia32_cr_probe_to_pdr": {
                  "description": "This is special creg for Probe Mode, details later",
                  "cr_offset": 8986,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "ia32_cr_uarch_misc_ctl": {
                  "description": "CMT 14015767073: Use MEC bit, no need for SCP backup",
                  "cr_offset": 273,
                  "numbits": 8,
                  "desired_value": "0x3440580000",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_ler_to_lip": {
                  "description": "One of the 3 MSRs that make up the Last Exception Record i.e. the last branch instruction that the processor executed prior to the last exception that was generated or the last interrupt that was handled. This part of the stack has the LIP of the destination instruction",
                  "cr_offset": 46,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_ler_from_lip": {
                  "description": "One of the 3 MSRs that make up the Last Exception Record i.e. the last branch instruction that the processor executed prior to the last exception that was generated or the last interrupt that was handled. This part of the stack has the LIP of the source instruction",
                  "cr_offset": 45,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ia32_cr_ler_info": {
                  "description": "One of the 3 MSRs that make up the Last Exception Record i.e. the last branch instruction that the processor executed prior to the last exception that was generated or the last interrupt that was handled. This part of the LER contains flag and elapsed cycle information",
                  "cr_offset": 51,
                  "numbits": 64,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ucode_cr_pic_msg_control": {
                  "description": "MSR used to enable/disable TPR messages. See Nehalem-B bug 2425138.",
                  "cr_offset": 8900,
                  "numbits": 16,
                  "desired_value": "0x801400",
                  "ref_value": "0x1000"
            },
            "thread0.virt_cr_smm_clear_smi": {
                  "description": "SMM Write only server MSR",
                  "cr_offset": 8862,
                  "numbits": 8,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.virt_cr_pppe_event_status": {
                  "description": "    This is a virtual register to combine the PPPE-accessible    events into a single XuMSR. The bits are sourced from    BUS_CR_PENDING_* and ARR_CR_VMCTL",
                  "cr_offset": 8863,
                  "numbits": 64,
                  "desired_value": "0x2000",
                  "ref_value": "0x0"
            },
            "thread0.ucode_cr_bios_done": {
                  "description": "BIOS Done MSR for Cannonlake i1351547. This replaces MSR 0x120 POWER_MISC[ENABLE_IA_UNTRUSTED_MODE]",
                  "cr_offset": 9095,
                  "numbits": 8,
                  "desired_value": "0x0",
                  "ref_value": "0x1"
            },
            "thread0.virt_cr_vmx_control": {
                  "description": "    This MSR provides PPPE access to the POST_VMXON bit. No reserved bit checks currently to match Skylake.",
                  "cr_offset": 1731,
                  "numbits": 64,
                  "desired_value": "0x1819",
                  "ref_value": "0x1a1b"
            },
            "thread0.virt_cr_stlb_fill_translation": {
                  "description": "STLB QoS MSR (Atom specific) to fill translations into STLB",
                  "cr_offset": 1352,
                  "numbits": 64,
                  "desired_value": "0x3f",
                  "ref_value": "0x3f"
            },
            "thread0.virt_cr_rtit_fup_data": {
                  "description": "\n        Used by the RTIT FUP generating ucode and ARR HW\n      ",
                  "cr_offset": 128,
                  "numbits": 16,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.virt_cr_rtit_tip_data": {
                  "description": "\n        Used by the RTIT FUP generating ucode and ARR HW\n      ",
                  "cr_offset": 129,
                  "numbits": 16,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.virt_cr_rtit_ptwrite32_command": {
                  "description": "\n        Used by the PTWRITE32 ucode and ARR HW\n      ",
                  "cr_offset": 130,
                  "numbits": 16,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.virt_cr_rtit_generic_command": {
                  "description": "\n        Used by the RTIT ucode packets and ARR HW\n      ",
                  "cr_offset": 131,
                  "numbits": 16,
                  "desired_value": "0x0",
                  "ref_value": "0x0"
            },
            "thread0.ucode_cr_unwind": {
                  "description": "unwind creg.",
                  "cr_offset": 0,
                  "numbits": 32,
                  "desired_value": "0x14",
                  "ref_value": "0x14"
            }
      }
}