
class EditExperimentWindow:
	def __init__(self, parent, data, update_callback):
		self.top = tk.Toplevel(parent)
		self.data = data
		title = f"Edit - {self.data['Test Name']}" if self.data else "Edit Experiment"
		self.top.title(title)
		
		
		self.entries = {}
		self.update_callback = update_callback
		self.original_types = {key: type(value) for key, value in data.items()}

		# Create a canvas and a scrollbar
		self.canvas = tk.Canvas(self.top)
		self.scrollbar = tk.Scrollbar(self.top, orient="vertical", command=self.canvas.yview)
		self.scrollable_frame = tk.Frame(self.canvas)

		self.scrollable_frame.bind(
			"<Configure>",
			lambda e: self.canvas.configure(
				scrollregion=self.canvas.bbox("all")
			)
		)

		self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw", width=800)
		self.canvas.configure(yscrollcommand=self.scrollbar.set)

		self.scrollbar.pack(side="right", fill="y")
		self.canvas.pack(side="left", fill="both", expand=True)


		self.create_widgets()
	
	def create_widgets(self):
		row = 0
		for key, value in self.data.items():
			
			tk.Label(self.scrollable_frame, text=key).grid(row=row, column=0, padx=10, pady=5, sticky=tk.W)
			entry = tk.Entry(self.scrollable_frame, width=100)
			entry.grid(row=row, column=1, columnspan=3, padx=10, pady=5)
			entry.insert(0, str(value) if value is not None else '')
			self.entries[key] = entry
			row += 1
		tk.Button(self.scrollable_frame, text="Save", command=self.save_changes).grid(row=row, column=0, columnspan=2, pady=10)

	
	def save_changes(self):
		for key, entry in self.entries.items():
			original_type = self.original_types[key]
			self.data[key] = self.convert_type(entry.get(), original_type) #if entry.get() != '' else None
		#for key, entry in self.entries.items():
		#	self.data[key] = entry.get() if entry.get() != '' else None
		self.update_callback(self.data)
		self.top.destroy()   

	def convert_type(self, value, original_type):
		if value == ''  or value == 'None':
			return None
		try:
			if original_type is bool:
				return value.lower() in ('true', '1', 'yes')
			return original_type(value)
		except ValueError:
			return value

class EditExperimentWindow3(tk.Toplevel):

	def __init__(self, parent, data, update_callback, config_file='GNRControlPanelConfig.json'):
		super().__init__(parent)
		self.data = data
		self.update_callback = update_callback
		self.config_file = config_file
		
		# Load configuration
		self.load_configuration()

		# Initialize all possible fields with default values if they don't exist
		self._initialize_missing_fields()

		self.input_vars = {
			key: tk.StringVar(value=str(value) if value is not None else '')
			for key, value in self.data.items()
		}

		# Initialize widgets and frames
		self.widgets = {}
		self.tab_frames = {}

		# Set window title
		title = f"Edit - {self.data.get('Test Name', 'Experiment')}"
		self.title(title)

		# Create main container
		container = tk.Frame(self)
		container.pack(fill="both", expand=True, padx=10, pady=10)

		# Create notebook for tabs
		self.notebook = ttk.Notebook(container)
		self.notebook.pack(fill="both", expand=True)

		# Create tabs
		self.create_tabs()
		
		# Create save button outside of tabs
		button_frame = tk.Frame(container)
		button_frame.pack(fill="x", pady=(10, 0))
		
		ttk.Button(button_frame, text="Save", command=self.save_changes).pack(side="right", padx=(5, 0))
		ttk.Button(button_frame, text="Cancel", command=self.on_closing).pack(side="right")

		# Set window size
		self.geometry("1200x800")
		self.protocol("WM_DELETE_WINDOW", self.on_closing)

		# Bind content change to update field visibility
		if 'Content' in self.input_vars:
			self.input_vars['Content'].trace('w', self.on_content_change)

	def _initialize_missing_fields(self):
		"""Initialize any missing fields with default values"""
		all_fields = set()
		
		# Collect all possible fields from data_types
		for field in self.data_types.keys():
			all_fields.add(field)
		
		# Add missing fields with appropriate default values
		for field in all_fields:
			if field not in self.data:
				field_types = self.data_types.get(field, [str])
				if bool in field_types:
					self.data[field] = False
				elif int in field_types:
					self.data[field] = 0
				elif float in field_types:
					self.data[field] = 0.0
				else:
					self.data[field] = ""

	def load_configuration(self):
		current_dir = os.path.dirname(__file__)
		with open(os.path.join(current_dir, self.config_file)) as config_file:
			config_data = json.load(config_file)

		# Convert string type names to actual types
		data_types_with_objects = {}
		type_mapping = {
			"str": str,
			"int": int,
			"float": float,
			"bool": bool,
			"dict": dict
		}
		
		for field, type_list in config_data['data_types'].items():
			data_types_with_objects[field] = [type_mapping[type_name] for type_name in type_list]

		self.data_types = data_types_with_objects
		self.TEST_MODES = config_data['TEST_MODES']
		self.TEST_TYPES = config_data['TEST_TYPES']
		self.VOLTAGE_TYPES = config_data['VOLTAGE_TYPES']
		self.MASK_OPTIONS = config_data['MASK_OPTIONS']
		self.TYPES = config_data['TYPES']
		self.DOMAINS = config_data['DOMAINS']
		self.CONTENT_OPTIONS = config_data['CONTENT_OPTIONS']
		self.CORE_LICENSE_OPTIONS = config_data['CORE_LICENSE_OPTIONS']
		self.DISABLE_2_CORES_OPTIONS = config_data['DISABLE_2_CORES_OPTIONS']
		self.fields_to_hide = config_data['fields_to_hide']
		self.field_descriptions = config_data['field_descriptions']
		self.mandatory_fields = config_data['mandatory_fields']
		self.FIELD_GROUPS = config_data['FIELD_GROUPS']

	def create_tabs(self):
		"""Create tabs for different categories"""
		tab_names = ["Config", "Linux", "EFI/Dragon"]
		
		for tab_name in tab_names:
			# Create tab frame
			tab_frame = ttk.Frame(self.notebook)
			self.notebook.add(tab_frame, text=tab_name)
			
			# Create scrollable content for each tab
			canvas = tk.Canvas(tab_frame)
			scrollbar = ttk.Scrollbar(tab_frame, orient="vertical", command=canvas.yview)
			scrollable_frame = ttk.Frame(canvas)
			
			scrollable_frame.bind(
				"<Configure>",
				lambda e, c=canvas: c.configure(scrollregion=c.bbox("all"))
			)
			
			canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
			canvas.configure(yscrollcommand=scrollbar.set)
			
			scrollbar.pack(side="right", fill="y")
			canvas.pack(side="left", fill="both", expand=True)
			
			# Store references
			self.tab_frames[tab_name] = {
				'canvas': canvas,
				'scrollable_frame': scrollable_frame,
				'scrollbar': scrollbar
			}
			
			# Populate tab content
			self.populate_tab_fields(tab_name, scrollable_frame)

	def populate_tab_fields(self, tab_name, parent_frame):
		"""Populate fields for a specific tab"""
		if tab_name not in self.FIELD_GROUPS:
			return
			
		selected_type = self.input_vars.get('Test Type', tk.StringVar()).get()
		hide_fields = self.fields_to_hide.get(selected_type, [])
		
		row = 0
		
		for group_name, fields in self.FIELD_GROUPS[tab_name].items():
			# Check if group has any visible fields
			visible_fields = [field for field in fields if field not in hide_fields and field in self.data_types]
			
			if not visible_fields:
				continue
				
			# Create group frame
			group_frame = ttk.LabelFrame(parent_frame, text=group_name, padding=(10, 6))
			group_frame.grid(row=row, column=0, sticky='EW', padx=10, pady=5)
			parent_frame.grid_columnconfigure(0, weight=1)
			
			field_row = 0
			for field in visible_fields:
				self.create_field_widget(group_frame, field, field_row)
				field_row += 1
				
			row += 1

	def create_field_widget(self, parent, field, row):
		"""Create widget for a specific field"""
		if field not in self.data_types:
			return
			
		field_types = self.data_types.get(field, [str])
		entry_widget = None
		
		# Create label
		label = ttk.Label(parent, text=field)
		label.grid(row=row, column=0, sticky='W', padx=5, pady=5)
		
		# Create appropriate widget based on field type and options
		if bool in field_types:
			entry_widget = ttk.Checkbutton(parent, variable=self.input_vars[field], 
										 onvalue='True', offvalue='False')
		elif field in ['Test Type', 'Test Mode', 'Configuration (Mask)', 'Type', 'Domain', 'Core License', 'Content', 'Voltage Type', 'Disable 2 Cores']:
			options_dict = {
				'Test Mode': self.TEST_MODES,
				'Test Type': self.TEST_TYPES,
				'Voltage Type': self.VOLTAGE_TYPES,
				'Configuration (Mask)': self.MASK_OPTIONS,
				'Type': self.TYPES,
				'Domain': self.DOMAINS,
				'Core License': self.CORE_LICENSE_OPTIONS,
				'Content': self.CONTENT_OPTIONS,
				'Disable 2 Cores': self.DISABLE_2_CORES_OPTIONS
			}
			options = options_dict.get(field, [])
			entry_widget = ttk.Combobox(parent, textvariable=self.input_vars[field], 
									  values=options, width=50)
			entry_widget.set(self.input_vars[field].get() or (options[0] if options else ""))
			
			if field == 'Test Type':
				entry_widget.bind("<<ComboboxSelected>>", self.on_test_type_change)
		else:
			# Regular entry widget
			entry_widget = ttk.Entry(parent, textvariable=self.input_vars[field], width=50)
		
		if entry_widget:
			entry_widget.grid(row=row, column=1, sticky='EW', padx=5, pady=5)
			parent.grid_columnconfigure(1, weight=1)
			
			# Create tooltip
			self.create_tooltip(label, self.field_descriptions.get(field, "No description available"))
			
			# Store widget reference
			if field not in self.widgets:
				self.widgets[field] = []
			self.widgets[field].append((label, entry_widget))

	def on_test_type_change(self, event=None):
		"""Handle test type change to show/hide relevant fields"""
		self.refresh_all_tabs()

	def on_content_change(self, *args):
		"""Handle content type change to show/hide content-specific fields"""
		# This could be used to highlight relevant tabs or fields
		content_type = self.input_vars.get('Content', tk.StringVar()).get()
		
		# You could add logic here to highlight or modify the appearance of 
		# Linux or EFI/Dragon tabs based on the selected content
		pass

	def refresh_all_tabs(self):
		"""Refresh all tabs to show/hide fields based on current selections"""
		# Clear existing widgets
		for field_widgets in self.widgets.values():
			for label, widget in field_widgets:
				label.destroy()
				widget.destroy()
		self.widgets.clear()
		
		# Recreate all tabs
		for tab_name, tab_data in self.tab_frames.items():
			# Clear the scrollable frame
			for widget in tab_data['scrollable_frame'].winfo_children():
				widget.destroy()
			
			# Repopulate
			self.populate_tab_fields(tab_name, tab_data['scrollable_frame'])

	def create_tooltip(self, widget, text):
		def on_enter(event):
			x = event.x_root + 10
			y = event.y_root + 10
			tooltip = tk.Label(self, text=text, background="lightyellow", 
							 relief="solid", borderwidth=1, wraplength=300)
			tooltip.place(x=x, y=y)
			widget.tooltip = tooltip

		def on_leave(event):
			if hasattr(widget, 'tooltip'):
				widget.tooltip.destroy()
				del widget.tooltip

		widget.bind("<Enter>", on_enter)
		widget.bind("<Leave>", on_leave)

	def save_changes(self):
		"""Save changes with validation"""
		error_messages = []
		missing_fields = self.highlight_missing_mandatory_fields()
		selected_type = self.input_vars['Test Type'].get()
		hide_fields = self.fields_to_hide.get(selected_type, [])
		validation_errors = self.validate_fields(excluded_fields=hide_fields)

		if missing_fields:
			error_messages.append(f"Missing mandatory fields: {', '.join(missing_fields)}")

		if validation_errors:
			error_messages.append("\n".join(validation_errors))

		if error_messages:
			messagebox.showerror("Validation Errors", "\n".join(error_messages))
			return

		# Convert and save values
		current_values = self.get_values()

		for field, original_value in self.data.items():
			new_value_str = current_values.get(field, original_value)
			field_types = self.data_types.get(field, [str])
			converted_value = None
			
			for field_type in field_types:
				try:
					if new_value_str is None or new_value_str == '':
						converted_value = None if field not in self.mandatory_fields else original_value
					elif field_type == bool:
						converted_value = new_value_str.lower() == 'true'
					elif field_type == int:
						converted_value = int(new_value_str)
					elif field_type == float:
						converted_value = float(new_value_str)
					elif field_type == str:
						converted_value = str(new_value_str)
					
					if converted_value is not None:
						self.data[field] = converted_value
						break
				except ValueError:
					continue

			if converted_value is None and field in self.data:
				self.data[field] = original_value

		self.update_callback(self.data)
		self.destroy()

	def get_values(self):
		return {field: (var.get().strip() if var.get() else None) 
				for field, var in self.input_vars.items()}

	def highlight_missing_mandatory_fields(self):
		"""Highlight missing mandatory fields"""
		missing_fields = []
		selected_type = self.input_vars['Test Type'].get()
		hide_fields = self.fields_to_hide.get(selected_type, [])

		for field in self.mandatory_fields:
			if field not in hide_fields:
				value = self.input_vars.get(field, tk.StringVar()).get().strip()
				if not value or value == 'None':
					missing_fields.append(field)
					# Highlight the field in red if it exists
					if field in self.widgets:
						for label, widget in self.widgets[field]:
							label.config(foreground="red")

		return missing_fields

	def validate_fields(self, excluded_fields=[]):
		"""Validate field values"""
		error_messages = []

		def is_valid_ip(ip):
			try:
				socket.inet_aton(ip)
				return True
			except socket.error:
				error_messages.append(f"IP Address '{ip}' is invalid")
				return False

		def validate_com_port(value):
			if not value or value == 'None':
				return True
			try:
				port_num = int(value)
				if 0 <= port_num <= 256:
					return True
				error_messages.append(f"COM Port '{value}' is out of range (0-256)")
				return False
			except ValueError:
				error_messages.append(f"COM Port '{value}' is not an integer")
				return False

		def validate_positive_integer(value):
			if not value or value == 'None':
				return True
			if value.isdigit() and int(value) > 0:
				return True
			error_messages.append(f"Test Number '{value}' is not a positive integer")
			return False

		def validate_non_negative_integer(value):
			if not value or value == 'None':
				return True
			if value.isdigit() and int(value) >= 0:
				return True
			error_messages.append(f"Check Core '{value}' is not a non-negative integer")
			return False

		def validate_existing_file(path):
			if not path or path == 'None':
				return True
			if os.path.isfile(path):
				return True
			error_messages.append(f"File '{path}' does not exist")
			return False

		def validate_existing_directory(path):
			if not path or path == 'None':
				return True
			if os.path.isdir(path):
				return True
			error_messages.append(f"Directory '{path}' does not exist")
			return False

		checks = {
			"COM Port": validate_com_port,
			"IP Address": is_valid_ip,
			"Test Number": validate_positive_integer,
			"Test Time": validate_positive_integer,
			"Check Core": validate_non_negative_integer,
			"Scripts File": validate_existing_file,
			"TTL Folder": validate_existing_directory,
			"ShmooFile": validate_existing_file
		}

		selected_type = self.input_vars['Test Type'].get()
		hide_fields = self.fields_to_hide.get(selected_type, [])

		for field, check in checks.items():
			if field in excluded_fields:
				continue

			value = self.input_vars[field].get()
			if not check(value):
				self.widgets[field][0].config(foreground="red")

		return error_messages

	def on_closing(self):
		"""Handle window closing event"""
		try:
			# Clean up any resources if needed
			for var in self.input_vars.values():
				try:
					var.set("")
				except:
					pass
			
			self.widgets.clear()
			self.tab_frames.clear()
			self.destroy()
			
		except Exception as e:
			print(f"Error during EditExperimentWindow2 cleanup: {e}")
			try:
				self.destroy()
			except:
				pass

class EditExperimentWindow2(tk.Toplevel):

	def __init__(self, parent, data, update_callback, config_file='GNRControlPanelConfig.json'):
		super().__init__(parent)
		self.data = data
		self.update_callback = update_callback

		self.config_file = config_file
		
		# Load configuration
		self.load_configuration()

		self.input_vars = {
			key: tk.StringVar(value=str(value) if value is not None else '')
			for key, value in data.items()
		}

		# Initialize widgets and frames
		self.widgets = {}
		self.frames = {}

		container = tk.Frame(self)
		container.pack(fill="both", expand=True)

		self.canvas = tk.Canvas(container)
		self.scrollable_frame = ttk.Frame(self.canvas)

		self.vertical_scrollbar = ttk.Scrollbar(container, orient="vertical", command=self.canvas.yview)
		self.horizontal_scrollbar = ttk.Scrollbar(container, orient="horizontal", command=self.canvas.xview)

		self.canvas.configure(yscrollcommand=self.vertical_scrollbar.set, xscrollcommand=self.horizontal_scrollbar.set)
		self.vertical_scrollbar.pack(side="right", fill="y")
		self.horizontal_scrollbar.pack(side="bottom", fill="x")
		self.canvas.pack(side="left", fill="both", expand=True)
		self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")

		self.scrollable_frame.bind("<Configure>", self.on_frame_configure)

		# Adjust window width for three columns with margin
		column_width = 420  # Estimated width per column
		fixed_width = column_width * 3 + 100  # Margin adjustment
		fixed_height = 800

		self.geometry(f"{fixed_width}x{fixed_height}")

		self.create_form()
		self.create_buttons()
		self.protocol("WM_DELETE_WINDOW", self.on_closing)

	def load_configuration(self):
		current_dir = os.path.dirname(__file__)
		with open(os.path.join(current_dir, self.config_file)) as config_file:
			config_data = json.load(config_file)

		# Convert string type names to actual types
		data_types_with_objects = {}
		type_mapping = {
			"str": str,
			"int": int,
			"float": float,
			"bool": bool,
			"dict":dict
		}
		
		for field, type_list in config_data['data_types'].items():
			data_types_with_objects[field] = [type_mapping[type_name] for type_name in type_list]

		self.data_types = data_types_with_objects
		self.TEST_MODES = config_data['TEST_MODES']
		self.TEST_TYPES = config_data['TEST_TYPES']
		self.VOLTAGE_TYPES=config_data['VOLTAGE_TYPES']
		self.MASK_OPTIONS = config_data['MASK_OPTIONS']
		self.TYPES = config_data['TYPES']
		self.DOMAINS = config_data['DOMAINS']
		self.CONTENT_OPTIONS = config_data['CONTENT_OPTIONS']
		self.CORE_LICENSE_OPTIONS = config_data['CORE_LICENSE_OPTIONS']
		self.fields_to_hide = config_data['fields_to_hide']
		self.field_descriptions = config_data['field_descriptions']
		self.mandatory_fields = config_data['mandatory_fields']
		self.FIELD_GROUPS = config_data['FIELD_GROUPS']
		self.DISABLE_2_CORES_OPTIONS = config_data['DISABLE_2_CORES_OPTIONS']

	def on_frame_configure(self, event):
		self.canvas.configure(scrollregion=self.canvas.bbox("all"))

	def create_form(self):
		self.populate_fields()

	def populate_fields(self, event=None):
		for widget in self.widgets.values():
			for element in widget:
				element.grid_remove()
		self.widgets.clear()
		for frame in self.frames.values():
			frame.grid_remove()
		self.frames.clear()

		frame_row = 0
		frame_col = 0
		selected_type = self.input_vars['Test Type'].get()
		hide_fields = self.fields_to_hide.get(selected_type, [])

		for group_name, fields in self.FIELD_GROUPS.items():
			has_visible_fields = any(field not in hide_fields for field in fields)

			if has_visible_fields:
				style = ttk.Style()
				style.configure("TLabelframe.Label", font=("Arial", 11, "bold"))
				frame = ttk.LabelFrame(
					self.scrollable_frame, text=group_name, padding=(10, 6),
					style="TLabelframe"
				)
				frame.grid(row=frame_row, column=frame_col, sticky='EW', padx=10, pady=5)
				self.frames[group_name] = frame

				row = 0
				for field in fields:
					if field not in hide_fields:
						field_types = self.data_types.get(field, [str])
						entry_widget = None

						if bool in field_types:
							entry_widget = tk.Checkbutton(frame, variable=self.input_vars[field], onvalue='True', offvalue='False')
						elif field in ['Test Type', 'Test Mode', 'Configuration (Mask)', 'Type', 'Domain', 'Core License']:
							options_dict = {
								'Test Mode': self.TEST_MODES, 
								'Test Type': self.TEST_TYPES, 
								'Voltage Type':self.VOLTAGE_TYPES,
								'Configuration (Mask)': self.MASK_OPTIONS, 
								'Type': self.TYPES, 
								'Domain': self.DOMAINS, 
								'Core License': self.CORE_LICENSE_OPTIONS
							}
							options = options_dict[field]
							entry_widget = ttk.Combobox(frame, textvariable=self.input_vars[field], values=options)
							entry_widget.set(self.input_vars[field].get() or options[0])
							if field == 'Test Type':
								entry_widget.bind("<<ComboboxSelected>>", self.populate_fields)
						elif field == 'Content':
							entry_widget = ttk.Combobox(frame, textvariable=self.input_vars[field], values=self.CONTENT_OPTIONS)
							entry_widget.set(self.input_vars[field].get() or self.CONTENT_OPTIONS[0])
						elif field == 'Voltage Type':
							entry_widget = ttk.Combobox(frame, textvariable=self.input_vars[field], values=self.VOLTAGE_TYPES)
							entry_widget.set(self.input_vars[field].get() or self.VOLTAGE_TYPES[0])
						elif field == 'Disable 2 Cores':
							entry_widget = ttk.Combobox(frame, textvariable=self.input_vars[field], values=self.DISABLE_2_CORES_OPTIONS)
							entry_widget.set(self.input_vars[field].get() or self.DISABLE_2_CORES_OPTIONS[0])
						else:
							entry_widget = ttk.Entry(frame, textvariable=self.input_vars[field], width=50)

						if entry_widget:
							label = ttk.Label(frame, text=field)
							label.grid(row=row, column=0, sticky='W', padx=5, pady=5)
							entry_widget.grid(row=row, column=1, sticky='EW', padx=5, pady=5)
							self.create_tooltip(label, self.field_descriptions.get(field, "No description available"))
							self.widgets[field] = (label, entry_widget)
							row += 1

				# Adjust for maximum columns you can fit
				if frame_col == 2:  
					frame_row += 1
					frame_col = 0
				else:
					frame_col += 1

	def create_buttons(self):
		save_button = ttk.Button(self.scrollable_frame, text="Save", command=self.save_changes)
		save_button.grid(row=len(self.frames) + 1, column=0, columnspan=4, pady=10)

	def save_changes(self):
		error_messages = []
		missing_fields = self.highlight_missing_mandatory_fields()
		selected_type = self.input_vars['Test Type'].get()
		hide_fields = self.fields_to_hide.get(selected_type, [])
		validation_errors = self.validate_fields(excluded_fields=hide_fields)

		if missing_fields:
			error_messages.append(f"Missing fields: {', '.join(missing_fields)}")

		if validation_errors:
			error_messages.append("\n".join(validation_errors))

		if error_messages:
			messagebox.showerror("Errors", "\n".join(error_messages))
			return

		current_values = self.get_values()

		for field, original_value in self.data.items():
			new_value_str = current_values.get(field, original_value)
			field_types = self.data_types[field]
			converted_value = None
			for field_type in field_types:
				try:
					if new_value_str is None or new_value_str == '':
						converted_value = None if field not in self.mandatory_fields else original_value
					elif field_type == bool:
						converted_value = new_value_str.lower() == 'true'
					elif field_type == int:
						converted_value = int(new_value_str)
					elif field_type == float:
						converted_value = float(new_value_str)
					elif field_type == str:
						converted_value = str(new_value_str)
					if converted_value is not None:
						self.data[field] = converted_value
						break
				except ValueError:
					continue

			if converted_value is None:
				self.data[field] = original_value

		self.update_callback(self.data)
		self.destroy()

	def get_values(self):
		return {field: (var.get().strip() if var.get() else None) for field, var in self.input_vars.items()}

	def highlight_missing_mandatory_fields(self):
		missing_fields = []
		selected_type = self.input_vars['Test Type'].get()
		hide_fields = self.fields_to_hide.get(selected_type, [])

		for field in self.mandatory_fields + [key for key, val in self.data_types.items() if bool in val]:
			value = self.input_vars[field].get().strip()
			if field not in hide_fields and (not value or value == 'None'):
				self.widgets[field][0].config(foreground="red")
				missing_fields.append(field)

		return missing_fields

	def create_tooltip(self, widget, text):
		def on_enter(event):
			# Use event coordinates to place the tooltip at mouse cursor location
			x = event.x_root + 10  # Slight offset for better visibility
			y = event.y_root + 10
			tooltip = tk.Label(self, text=text, background="lightyellow", relief="solid", borderwidth=1)
			tooltip.place(x=x, y=y)
			widget.tooltip = tooltip

		def on_leave(event):
			if hasattr(widget, 'tooltip'):
				widget.tooltip.destroy()
				del widget.tooltip

		widget.bind("<Enter>", on_enter)
		widget.bind("<Leave>", on_leave)

	def validate_fields(self, excluded_fields=[]):
		error_messages = []

		def is_valid_ip(ip):
			try:
				socket.inet_aton(ip)
				return True
			except socket.error:
				error_messages.append(f"IP Address '{ip}' is invalid")
				return False

		def validate_com_port(value):
			if not value or value == 'None':
				return True
			try:
				port_num = int(value)
				if 0 <= port_num <= 256:
					return True
				error_messages.append(f"COM Port '{value}' is out of range (0-256)")
				return False
			except ValueError:
				error_messages.append(f"COM Port '{value}' is not an integer")
				return False

		def validate_positive_integer(value):
			if not value or value == 'None':
				return True
			if value.isdigit() and int(value) > 0:
				return True
			error_messages.append(f"Test Number '{value}' is not a positive integer")
			return False

		def validate_non_negative_integer(value):
			if not value or value == 'None':
				return True
			if value.isdigit() and int(value) >= 0:
				return True
			error_messages.append(f"Check Core '{value}' is not a non-negative integer")
			return False

		def validate_existing_file(path):
			if not path or path == 'None':
				return True
			if os.path.isfile(path):
				return True
			error_messages.append(f"File '{path}' does not exist")
			return False

		def validate_existing_directory(path):
			if not path or path == 'None':
				return True
			if os.path.isdir(path):
				return True
			error_messages.append(f"Directory '{path}' does not exist")
			return False

		checks = {
			"COM Port": validate_com_port,
			"IP Address": is_valid_ip,
			"Test Number": validate_positive_integer,
			"Test Time": validate_positive_integer,
			"Check Core": validate_non_negative_integer,
			"Scripts File": validate_existing_file,
			"TTL Folder": validate_existing_directory,
			"ShmooFile": validate_existing_file
		}

		selected_type = self.input_vars['Test Type'].get()
		hide_fields = self.fields_to_hide.get(selected_type, [])

		for field, check in checks.items():
			if field in excluded_fields:
				continue

			value = self.input_vars[field].get()
			if not check(value):
				self.widgets[field][0].config(foreground="red")

		return error_messages
