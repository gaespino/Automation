"""
report_builder.py — Build experiment configuration reports in Markdown, HTML, and PDF.

Outputs:
  - Markdown (.md)     : always available, zero deps
  - HTML    (.html)    : always available, embedded CSS, print-to-PDF ready
  - PDF     (.pdf)     : optional, requires:  pip install "fpdf2>=2.7"

Usage:
    from _core import report_builder
    md   = report_builder.build_markdown(experiment, product="GNR")
    html = report_builder.build_html(experiment, product="GNR")
    report_builder.write_pdf(experiment, out_path, product="GNR")   # optional
"""

from __future__ import annotations
import pathlib
import re
import sys
from datetime import datetime
from typing import Any

# --------------------------------------------------------------------------
# Field grouping — controls section order and which fields appear where
# --------------------------------------------------------------------------

_SECTION_FIELDS: dict[str, list[str]] = {
    "Basic Settings": [
        "Experiment", "Test Name", "Test Mode", "Test Type",
        "Visual ID", "Bucket", "Test Number", "Test Time",
        "Content",
    ],
    "Connection & Unit": [
        "COM Port", "IP Address", "Check Core",
        "Core License", "600W Unit", "Pseudo Config",
    ],
    "Test Execution": [
        "Loops", "Reset", "Reset on PASS", "FastBoot",
        "Stop on Fail", "Pass String", "Fail String",
        "Post Process", "Configuration (Mask)", "Boot Breakpoint",
    ],
    "Voltage & Frequency": [
        "Voltage Type", "Voltage IA", "Voltage CFC",
        "Frequency IA", "Frequency CFC",
        "Type", "Domain", "Start", "End", "Steps",
    ],
    "Dragon Content": [
        "ULX Path", "ULX CPU", "Product Chop",
        "Dragon Content Path", "Dragon Content Line",
        "Startup Dragon", "Dragon Pre Command", "Dragon Post Command",
        "VVAR0", "VVAR1", "VVAR2", "VVAR3", "VVAR_EXTRA",
    ],
    "Linux Content": [
        "Linux Path", "Startup Linux",
        "Linux Pre Command", "Linux Post Command",
        "Linux Pass String", "Linux Fail String",
        "Linux Content Wait Time",
        *[f"Linux Content Line {i}" for i in range(10)],
    ],
    "PYSVConsole Content": [
        "Scripts File",
    ],
    "Fuse / BIOS": [
        "Fuse File", "Bios File",
    ],
    "Shmoo": [
        "ShmooFile", "ShmooLabel",
    ],
    "Merlin": [
        "Merlin Name", "Merlin Drive", "Merlin Path",
    ],
    "Core Disable": [
        "Disable 2 Cores", "Disable 1 Core",
    ],
    "TTL Config": [
        "TTL Folder",
    ],
}

# Sections to hide completely when all fields are empty/None
_SKIP_WHEN_EMPTY = {
    "Dragon Content", "Linux Content", "PYSVConsole Content",
    "Fuse / BIOS", "Shmoo", "Core Disable",
}

# Fields always shown (never skip)
_ALWAYS_SHOW_SECTIONS = {
    "Basic Settings", "Connection & Unit", "Test Execution",
    "Voltage & Frequency", "Merlin", "TTL Config",
}


def _fmt_value(v: Any) -> str:
    if v is None:
        return "—"
    if isinstance(v, bool):
        return "Yes" if v else "No"
    return str(v)


def _section_has_data(exp: dict, fields: list[str]) -> bool:
    return any(
        exp.get(f) not in (None, "", 0, False)
        for f in fields
    )


def _iter_sections(exp: dict):
    """Yield (section_name, [(field, value), ...]) for all non-empty sections."""
    for section, fields in _SECTION_FIELDS.items():
        rows = [(f, exp.get(f)) for f in fields if f in exp]
        if not rows:
            continue
        if section in _SKIP_WHEN_EMPTY and not _section_has_data(exp, fields):
            continue
        yield section, rows


# --------------------------------------------------------------------------
# Markdown builder
# --------------------------------------------------------------------------

def build_markdown(
    experiment:        dict[str, Any],
    validation_result: tuple | None = None,
    product:           str | None = None,
    generated_by:      str = "DebugFrameworkAgent",
) -> str:
    now   = datetime.now().strftime("%Y-%m-%d  %H:%M:%S")
    name  = experiment.get("Test Name", "Untitled")
    mode  = experiment.get("Test Mode",  "—")
    ttype = experiment.get("Test Type",  "—")
    cont  = experiment.get("Content",    "—")
    prod  = product or experiment.get("Product Chop", "Unknown")

    lines: list[str] = []

    # ── Header ──────────────────────────────────────────────────────────
    lines += [
        f"# Experiment Report — {name}",
        "",
        f"| | |",
        f"|---|---|",
        f"| **Generated** | {now} |",
        f"| **Product**   | {prod} |",
        f"| **Test Mode** | {mode} |",
        f"| **Test Type** | {ttype} |",
        f"| **Content**   | {cont} |",
        f"| **Generated by** | {generated_by} |",
        "",
        "---",
        "",
    ]

    # ── Sections ─────────────────────────────────────────────────────────
    for section, rows in _iter_sections(experiment):
        lines.append(f"## {section}")
        lines.append("")
        lines.append("| Field | Value |")
        lines.append("|-------|-------|")
        for field, value in rows:
            lines.append(f"| `{field}` | {_fmt_value(value)} |")
        lines.append("")

    # ── Validation results ───────────────────────────────────────────────
    if validation_result is not None:
        ok, errors, warnings = validation_result
        lines.append("## Validation Results")
        lines.append("")
        if ok and not warnings:
            lines.append("> **PASS** — All required fields set, no issues found.")
        elif ok:
            lines.append("> **PASS** — Valid with warnings:")
        else:
            lines.append("> **FAIL** — Experiment has validation errors:")
        lines.append("")
        for e in errors:
            lines.append(f"- **ERROR:** {e}")
        for w in warnings:
            lines.append(f"- *Warning:* {w}")
        lines.append("")

    # ── Footer ───────────────────────────────────────────────────────────
    lines += [
        "---",
        "",
        f"*Report generated by {generated_by} on {now}*",
        "",
    ]

    return "\n".join(lines)


# --------------------------------------------------------------------------
# HTML builder
# --------------------------------------------------------------------------

_HTML_CSS = """
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    font-size: 13px;
    color: #1a1a1a;
    max-width: 960px;
    margin: 32px auto;
    padding: 0 24px;
}
h1 { font-size: 22px; margin-bottom: 4px; color: #003366; border-bottom: 2px solid #003366; padding-bottom: 6px; }
h2 { font-size: 15px; font-weight: 600; color: #003366; margin-top: 28px; margin-bottom: 6px;
     border-left: 4px solid #0066cc; padding-left: 10px; }
table { border-collapse: collapse; width: 100%; margin-bottom: 16px; font-size: 12px; }
th { background: #003366; color: #fff; padding: 7px 12px; text-align: left; font-weight: 600; }
td { padding: 6px 12px; border-bottom: 1px solid #e0e0e0; vertical-align: top; }
tr:nth-child(even) td { background: #f5f8ff; }
td code { background: #e8eaf6; padding: 1px 5px; border-radius: 3px; font-size: 11px; font-family: 'Consolas', monospace; }
.meta-table td:first-child { color: #555; font-weight: 600; width: 130px; }
.pass  { color: #1a7c1a; font-weight: bold; }
.fail  { color: #cc0000; font-weight: bold; }
.warn  { color: #cc6600; }
.error { color: #cc0000; }
.footer { margin-top: 40px; font-size: 11px; color: #888; border-top: 1px solid #ddd; padding-top: 8px; }
.badge { display: inline-block; padding: 2px 10px; border-radius: 10px; font-size: 11px;
         font-weight: 700; letter-spacing: 0.5px; }
.badge-pass { background: #d4edda; color: #155724; }
.badge-fail { background: #f8d7da; color: #721c24; }
.badge-warn { background: #fff3cd; color: #856404; }
@media print {
    body { margin: 10mm; max-width: 100%; }
    h2 { page-break-after: avoid; }
    table { page-break-inside: avoid; }
}
"""


def build_html(
    experiment:        dict[str, Any],
    validation_result: tuple | None = None,
    product:           str | None = None,
    generated_by:      str = "DebugFrameworkAgent",
) -> str:
    now   = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    name  = experiment.get("Test Name", "Untitled")
    mode  = experiment.get("Test Mode",  "—")
    ttype = experiment.get("Test Type",  "—")
    cont  = experiment.get("Content",    "—")
    prod  = product or experiment.get("Product Chop", "Unknown")

    def _td(v: Any) -> str:
        fv = _fmt_value(v)
        if fv == "—":
            return f'<td style="color:#bbb">—</td>'
        return f"<td>{fv}</td>"

    def _th_row(label: str, val: str) -> str:
        return f"<tr><td>{label}</td><td><strong>{val}</strong></td></tr>"

    parts: list[str] = []

    # ── HTML wrapper ─────────────────────────────────────────────────────
    parts.append(f"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Experiment Report — {name}</title>
<style>{_HTML_CSS}</style>
</head>
<body>
<h1>Experiment Report — {name}</h1>
<table class="meta-table">
<tr><td>Generated</td><td>{now}</td></tr>
{_th_row("Product",      prod)}
{_th_row("Test Mode",    mode)}
{_th_row("Test Type",    ttype)}
{_th_row("Content",      cont)}
<tr><td>Generated by</td><td>{generated_by}</td></tr>
</table>
<hr>
""")

    # ── Sections ─────────────────────────────────────────────────────────
    for section, rows in _iter_sections(experiment):
        parts.append(f"<h2>{section}</h2>\n<table>")
        parts.append("<tr><th style='width:220px'>Field</th><th>Value</th></tr>")
        for field, value in rows:
            fv = _fmt_value(value)
            val_cell = f'<span style="color:#bbb">—</span>' if fv == "—" else fv
            parts.append(f"<tr><td><code>{field}</code></td><td>{val_cell}</td></tr>")
        parts.append("</table>\n")

    # ── Validation results ───────────────────────────────────────────────
    if validation_result is not None:
        ok, errors, warnings = validation_result
        badge = '<span class="badge badge-pass">PASS</span>' if ok else '<span class="badge badge-fail">FAIL</span>'
        if ok and warnings:
            badge = '<span class="badge badge-warn">PASS with warnings</span>'

        parts.append(f"<h2>Validation Results  {badge}</h2>")
        if errors or warnings:
            parts.append("<ul>")
            for e in errors:
                parts.append(f'<li class="error"><strong>ERROR:</strong> {e}</li>')
            for w in warnings:
                parts.append(f'<li class="warn"><em>Warning:</em> {w}</li>')
            parts.append("</ul>")
        else:
            parts.append("<p class='pass'>All required fields set, no issues found.</p>")

    # ── Footer ───────────────────────────────────────────────────────────
    parts.append(f"""
<div class="footer">
  Report generated by {generated_by} &mdash; {now}<br>
  <em>To save as PDF: open in browser and use File &rarr; Print &rarr; Save as PDF</em>
</div>
</body>
</html>
""")
    return "\n".join(parts)


# --------------------------------------------------------------------------
# PDF builder (optional — requires fpdf2>=2.7)
# --------------------------------------------------------------------------

def _check_fpdf2() -> bool:
    try:
        import fpdf  # noqa: F401
        return True
    except ImportError:
        return False


PDF_AVAILABLE = _check_fpdf2()


def write_pdf(
    experiment:        dict[str, Any],
    out_path:          pathlib.Path | str,
    validation_result: tuple | None = None,
    product:           str | None = None,
) -> pathlib.Path:
    """
    Write a PDF report for the experiment.

    Requires:  pip install "fpdf2>=2.7"
    If fpdf2 is not installed, raises ImportError with an install hint.
    """
    if not PDF_AVAILABLE:
        raise ImportError(
            "PDF generation requires fpdf2.\n"
            'Install it with:  pip install "fpdf2>=2.7"\n'
            "Alternatively, open the .html report in a browser and print to PDF."
        )

    from fpdf import FPDF  # type: ignore

    out_path = pathlib.Path(out_path).resolve()
    out_path.parent.mkdir(parents=True, exist_ok=True)

    now  = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    name = experiment.get("Test Name", "Untitled")
    prod = product or experiment.get("Product Chop", "Unknown")

    pdf = FPDF(orientation="P", unit="mm", format="A4")
    pdf.set_auto_page_break(auto=True, margin=14)
    pdf.add_page()

    # Title
    pdf.set_font("Helvetica", "B", 18)
    pdf.set_fill_color(0, 51, 102)
    pdf.set_text_color(255, 255, 255)
    pdf.cell(0, 10, f"Experiment Report", new_x="LMARGIN", new_y="NEXT", fill=True)
    pdf.ln(1)

    pdf.set_font("Helvetica", "B", 12)
    pdf.set_text_color(0, 51, 102)
    pdf.cell(0, 7, name, new_x="LMARGIN", new_y="NEXT")
    pdf.set_font("Helvetica", "", 9)
    pdf.set_text_color(100, 100, 100)
    pdf.cell(0, 5, f"Generated: {now}  |  Product: {prod}  |  Mode: {experiment.get('Test Mode','?')}  |  Type: {experiment.get('Test Type','?')}", new_x="LMARGIN", new_y="NEXT")
    pdf.ln(4)

    pdf.set_draw_color(0, 51, 102)
    pdf.set_line_width(0.4)
    pdf.line(10, pdf.get_y(), 200, pdf.get_y())
    pdf.ln(4)

    col_w_label = 68
    col_w_value = 120
    row_h = 6

    for section, rows in _iter_sections(experiment):
        # Section header
        pdf.set_font("Helvetica", "B", 10)
        pdf.set_fill_color(0, 51, 102)
        pdf.set_text_color(255, 255, 255)
        pdf.cell(0, 7, f"  {section}", new_x="LMARGIN", new_y="NEXT", fill=True)

        # Table header
        pdf.set_font("Helvetica", "B", 8)
        pdf.set_fill_color(220, 230, 242)
        pdf.set_text_color(0, 0, 0)
        pdf.cell(col_w_label, row_h, "Field", border=1, fill=True)
        pdf.cell(col_w_value, row_h, "Value", border=1, new_x="LMARGIN", new_y="NEXT", fill=True)

        pdf.set_font("Helvetica", "", 8)
        for i, (field, value) in enumerate(rows):
            fill = i % 2 == 0
            pdf.set_fill_color(245, 248, 255) if fill else pdf.set_fill_color(255, 255, 255)
            fv = _fmt_value(value)
            # Truncate long values
            if len(fv) > 60:
                fv = fv[:57] + "..."
            pdf.cell(col_w_label, row_h, str(field), border="LR", fill=fill)
            pdf.cell(col_w_value, row_h, fv, border="LR", new_x="LMARGIN", new_y="NEXT", fill=fill)
        # Close table bottom border
        pdf.set_fill_color(220, 230, 242)
        pdf.cell(col_w_label + col_w_value, 0, "", border="T")
        pdf.ln(5)

    # Validation results
    if validation_result is not None:
        ok, errors, warnings = validation_result
        pdf.set_font("Helvetica", "B", 10)
        pdf.set_fill_color(0, 51, 102)
        pdf.set_text_color(255, 255, 255)
        pdf.cell(0, 7, "  Validation Results", new_x="LMARGIN", new_y="NEXT", fill=True)

        pdf.set_font("Helvetica", "", 9)
        if ok and not warnings:
            pdf.set_text_color(26, 124, 26)
            pdf.cell(0, 6, "  PASS — All required fields set, no issues found.", new_x="LMARGIN", new_y="NEXT")
        for e in errors:
            pdf.set_text_color(204, 0, 0)
            pdf.cell(0, 6, f"  ERROR: {e[:90]}", new_x="LMARGIN", new_y="NEXT")
        for w in warnings:
            pdf.set_text_color(180, 90, 0)
            pdf.cell(0, 6, f"  Warning: {w[:90]}", new_x="LMARGIN", new_y="NEXT")
        pdf.ln(3)

    # Footer
    pdf.set_text_color(140, 140, 140)
    pdf.set_font("Helvetica", "I", 8)
    pdf.cell(0, 5, f"Generated by DebugFrameworkAgent  |  {now}", new_x="LMARGIN", new_y="NEXT")

    pdf.output(str(out_path))
    return out_path


# --------------------------------------------------------------------------
# Batch executive summary builders
# --------------------------------------------------------------------------

# Fields compared per content type — ordered by importance
_BATCH_COMPARE_FIELDS: dict[str, list[str]] = {
    "Dragon": [
        "Test Mode", "Check Core", "Bucket", "Loops", "Test Time",
        "Voltage Type", "Voltage IA", "Voltage CFC",
        "Configuration (Mask)", "Boot Breakpoint", "Pseudo Config",
        "ULX Path", "ULX CPU", "Product Chop",
        "Dragon Content Path", "Dragon Content Line",
        "Startup Dragon", "Dragon Pre Command", "Dragon Post Command",
        "VVAR0", "VVAR1", "VVAR2", "VVAR3", "VVAR_EXTRA",
    ],
    "Linux": [
        "Test Mode", "Check Core", "Bucket", "Loops", "Test Time",
        "Voltage Type", "Configuration (Mask)", "Boot Breakpoint",
        "Linux Path", "Startup Linux",
        "Linux Pre Command", "Linux Post Command",
        "Linux Pass String", "Linux Fail String",
        "Linux Content Wait Time",
        *[f"Linux Content Line {i}" for i in range(10)],
    ],
    "PYSVConsole": [
        "Test Mode", "Check Core", "Bucket", "Loops", "Test Time",
        "Voltage Type", "Configuration (Mask)", "Boot Breakpoint",
        "Scripts File", "Bios File", "Fuse File",
    ],
}

# Fallback — all known section fields, minus identity-only fields
_BATCH_COMPARE_FIELDS_DEFAULT: list[str] = [
    f
    for fields in _SECTION_FIELDS.values()
    for f in fields
    if f not in ("Test Name", "Test Number", "Visual ID", "Experiment", "Content")
]

# Fields that uniquely identify an experiment — excluded from comparison
_IDENTITY_FIELDS: frozenset[str] = frozenset({
    "Test Name", "Test Number", "Visual ID", "Experiment",
})


def _group_by_content(experiments: list[dict]) -> dict[str, list[dict]]:
    """Return experiments grouped by their Content field value."""
    groups: dict[str, list[dict]] = {}
    for exp in experiments:
        key = exp.get("Content") or "Unknown"
        groups.setdefault(key, []).append(exp)
    return groups


def _common_and_diff(
    exps: list[dict],
    fields: list[str],
) -> tuple[dict[str, Any], list[str]]:
    """
    Split *fields* into common (identical value across all exps) and diff (any variation).

    Returns:
        common_dict  — {field: value} for fields identical across every experiment.
        diff_fields  — list of field names that vary between at least two experiments.
    """
    common: dict[str, Any] = {}
    diff_fields: list[str] = []
    for field in fields:
        values = [exp.get(field) for exp in exps]
        if all(v is None for v in values):
            continue  # skip fully absent fields
        if len({_fmt_value(v) for v in values}) == 1:
            common[field] = values[0]
        else:
            diff_fields.append(field)
    return common, diff_fields


def build_batch_summary_markdown(
    experiments:  list[dict[str, Any]],
    product:      str | None = None,
    batch_name:   str | None = None,
    generated_by: str = "DebugFrameworkAgent",
) -> str:
    """
    Build a Markdown executive summary for a batch of experiments.

    Groups experiments by Content type (Dragon / Linux / PYSVConsole / …),
    then reports common vs. differing fields within each group.
    """
    now    = datetime.now().strftime("%Y-%m-%d  %H:%M:%S")
    prod   = product or "—"
    b_name = batch_name or "Batch Summary"
    groups = _group_by_content(experiments)
    lines: list[str] = []

    # ── Title / header meta-table ─────────────────────────────────────
    lines += [
        f"# {b_name}",
        "",
        "| | |",
        "|---|---|",
        f"| **Generated** | {now} |",
        f"| **Product** | {prod} |",
        f"| **Total Experiments** | {len(experiments)} |",
    ]
    for ctype, exps in groups.items():
        lines.append(f"| **{ctype} Experiments** | {len(exps)} |")
    lines += [
        f"| **Generated by** | {generated_by} |",
        "",
        "---",
        "",
    ]

    # ── Experiment Index ──────────────────────────────────────────────
    lines += [
        "## Experiment Index",
        "",
        "| # | Test Name | Mode | Type | Content | Bucket | Check Core |",
        "|---|-----------|------|------|---------|--------|------------|",
    ]
    for i, exp in enumerate(experiments, 1):
        lines.append(
            f"| {i} "
            f"| {_fmt_value(exp.get('Test Name'))} "
            f"| {_fmt_value(exp.get('Test Mode'))} "
            f"| {_fmt_value(exp.get('Test Type'))} "
            f"| {_fmt_value(exp.get('Content'))} "
            f"| {_fmt_value(exp.get('Bucket'))} "
            f"| {_fmt_value(exp.get('Check Core'))} |"
        )
    lines.append("")

    # ── Per-content-type sections ─────────────────────────────────────
    for ctype, exps in groups.items():
        lines += [
            "---",
            "",
            f"## {ctype} Experiments  ({len(exps)} total)",
            "",
        ]
        compare_fields = _BATCH_COMPARE_FIELDS.get(ctype, _BATCH_COMPARE_FIELDS_DEFAULT)
        common, diff_fields = _common_and_diff(exps, compare_fields)

        # Common configuration
        lines += ["### Common Configuration", ""]
        if common:
            lines.append("All experiments in this group share the following settings:")
            lines += ["", "| Field | Value |", "|-------|-------|"]
            for field, value in common.items():
                lines.append(f"| `{field}` | {_fmt_value(value)} |")
            lines.append("")
        else:
            lines += [
                "> No fields are identical across all experiments in this group.",
                "",
            ]

        # Differences between experiments
        lines += ["### Differences Between Experiments", ""]
        if diff_fields:
            exp_names = [e.get("Test Name") or f"Exp {i + 1}" for i, e in enumerate(exps)]
            header = "| Field | " + " | ".join(exp_names) + " |"
            sep    = "|-------|" + "|".join(["----"] * len(exps)) + "|"
            lines += [header, sep]
            for field in diff_fields:
                row_vals = " | ".join(_fmt_value(e.get(field)) for e in exps)
                lines.append(f"| `{field}` | {row_vals} |")
            lines.append("")
        else:
            lines += [
                "> All compared fields are identical — no differences found.",
                "",
            ]

    # ── Footer ────────────────────────────────────────────────────────
    lines += [
        "---",
        "",
        f"*Batch summary generated by {generated_by} on {now}*",
        "",
    ]
    return "\n".join(lines)


def build_batch_summary_html(
    experiments:  list[dict[str, Any]],
    product:      str | None = None,
    batch_name:   str | None = None,
    generated_by: str = "DebugFrameworkAgent",
) -> str:
    """
    Build a styled HTML executive summary for a batch of experiments.

    Groups experiments by Content type (Dragon / Linux / PYSVConsole / …),
    then reports common vs. differing fields within each group.
    """
    now    = datetime.now().strftime("%Y-%m-%d  %H:%M:%S")
    prod   = product or "—"
    b_name = batch_name or "Batch Summary"
    groups = _group_by_content(experiments)

    def esc(s: str) -> str:
        return (
            str(s)
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;")
        )

    parts: list[str] = []

    # ── Title / meta-table ────────────────────────────────────────────
    parts.append(f"<h1>{esc(b_name)}</h1>")
    meta_rows  = [("Generated", now), ("Product", prod), ("Total Experiments", str(len(experiments)))]
    for ctype, exps in groups.items():
        meta_rows.append((f"{ctype} Experiments", str(len(exps))))
    meta_rows.append(("Generated by", generated_by))

    tbl = '<table class="meta-table"><tbody>'
    for label, val in meta_rows:
        tbl += f"<tr><td>{esc(label)}</td><td>{esc(val)}</td></tr>"
    tbl += "</tbody></table>"
    parts.append(tbl)

    # ── Experiment Index ──────────────────────────────────────────────
    parts.append("<h2>Experiment Index</h2>")
    idx = "<table><thead><tr>"
    for col in ("#", "Test Name", "Mode", "Type", "Content", "Bucket", "Check Core"):
        idx += f"<th>{esc(col)}</th>"
    idx += "</tr></thead><tbody>"
    for i, exp in enumerate(experiments, 1):
        idx += "<tr>"
        idx += f"<td>{i}</td>"
        for field in ("Test Name", "Test Mode", "Test Type", "Content", "Bucket", "Check Core"):
            idx += f"<td>{esc(_fmt_value(exp.get(field)))}</td>"
        idx += "</tr>"
    idx += "</tbody></table>"
    parts.append(idx)

    # ── Per-content-type sections ─────────────────────────────────────
    for ctype, exps in groups.items():
        parts.append(
            f'<hr/><h2>{esc(ctype)} Experiments '
            f'<small>({len(exps)} total)</small></h2>'
        )
        compare_fields = _BATCH_COMPARE_FIELDS.get(ctype, _BATCH_COMPARE_FIELDS_DEFAULT)
        common, diff_fields = _common_and_diff(exps, compare_fields)

        # Common configuration
        parts.append("<h3>Common Configuration</h3>")
        if common:
            parts.append("<p>All experiments in this group share the following settings:</p>")
            tbl = "<table><thead><tr><th>Field</th><th>Value</th></tr></thead><tbody>"
            for field, value in common.items():
                tbl += f"<tr><td><code>{esc(field)}</code></td><td>{esc(_fmt_value(value))}</td></tr>"
            tbl += "</tbody></table>"
            parts.append(tbl)
        else:
            parts.append("<p><em>No fields are identical across all experiments in this group.</em></p>")

        # Differences
        parts.append("<h3>Differences Between Experiments</h3>")
        if diff_fields:
            exp_names = [e.get("Test Name") or f"Exp {i + 1}" for i, e in enumerate(exps)]
            tbl = "<table><thead><tr><th>Field</th>"
            for n in exp_names:
                tbl += f"<th>{esc(str(n))}</th>"
            tbl += "</tr></thead><tbody>"
            for field in diff_fields:
                tbl += f"<tr><td><code>{esc(field)}</code></td>"
                for exp in exps:
                    tbl += f"<td>{esc(_fmt_value(exp.get(field)))}</td>"
                tbl += "</tr>"
            tbl += "</tbody></table>"
            parts.append(tbl)
        else:
            parts.append("<p><em>All compared fields are identical — no differences found.</em></p>")

    body    = "\n".join(parts)
    footer  = f'<div class="footer">Batch summary generated by {esc(generated_by)} on {esc(now)}</div>'
    h3_css  = (
        "h3 { font-size: 13px; font-weight: 700; color: #1a4a8a; margin-top: 18px; margin-bottom: 4px; "
        "padding-left: 6px; border-left: 3px solid #5588cc; }"
    )
    small_css = "small { font-weight: normal; font-size: 12px; color: #666; }"

    return f"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>{esc(b_name)}</title>
<style>
{_HTML_CSS}
{h3_css}
{small_css}
</style>
</head>
<body>
{body}
{footer}
</body>
</html>"""
